{"version":3,"file":"279.191ac87f.iframe.bundle.js","mappings":";;AAOA;AACA;;;;;;AAQA;AAYA;;;;;;;;AAQA;AACA;AACA;AACA;;;;AAIA;;;;AAIA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;AAvCA;AAyCA;AACA;;;;AArCA;AA0CA;AACA;;AAEA;;AAlDA;;;;;;;ACZA;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;AAeA;;;;;;;;AAQA;;AAEA;;;;;;AAMA;;;;;;;AAOA;;;;;AAKA;;;;;;;;;;;;;AAaA;;;AAIA;;;;;AAKA;AACA;AACA;AACA;;;;;AAKA;;;AAGA;;AC5FA;ACJA;AACA;AACA;;;AAGA;ACLA;;;;;;ACIA;AACA;;;;;AAKA;;;;AAIA;AACA;;;;;;AClBA;;;;;;;;ACYA;;AAEA;AACA;AAMA;AAMA;;AAOA;;;;AAIA;;;;AAIA;;;;;AAKA;AACA;;AC7CA;;AAGA;;AAOA;;AAEA;;;;AAMA;;;AAGA;;AAIA;;;;;;AAMA;AACA;;;;;;;;AAQA;;;;;AAKA;;AAGA;;AAEA;;;;;;ACzCA;;;;;ADsDA;AACA;AACA;AACA;AE7DA;;;;;;;;ACqEA;;;;;AC3EA;AC2BA;;AAEA;AAEA;ACxBA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;AAGA;;AC3XA;;;;ACsCA;ACCA;;AAEA;;;;;AAQA;AClDA;;AAEA;;AA8DA;;;;AAoBA;;;;AAYA;;;;AClEA;ACgDA;;;AAIA;AAKA;;;AAIA;;;AC3GA;;;;;ACGA;;;ACOA;ACOA;;;;;AAMA;;;;;;AC2CA;;AAsNA;;;;AC7NA;ACwCA;;;;AClEA;;;;AA6DA;AACA;;;;AAUA;;AA6RA;;;;AC7YA","sources":["webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/GlobalStyle.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/ThemeSwitch/components.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/ThemeSwitch/index.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/Select/Wrapper.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/Select/Option/index.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/_Input/Wrapper.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/_Input/reducer.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/Input/Wrapper.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/Input/components.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/utils/theme-helpers.js","webpack://search-ui/./node_modules/@advtr/tidy/dist/esm/components/Input/index.js","webpack://search-ui/./node_modules/@storybook/addon-actions/dist/esm/preview/withActions.js","webpack://search-ui/./node_modules/@storybook/addon-backgrounds/dist/esm/preview.js","webpack://search-ui/./node_modules/@storybook/addon-backgrounds/dist/esm/helpers/index.js","webpack://search-ui/./node_modules/@storybook/addon-outline/dist/esm/outlineCSS.js","webpack://search-ui/./node_modules/@storybook/builder-webpack5/node_modules/@storybook/channels/dist/esm/index.js","webpack://search-ui/./node_modules/@storybook/store/dist/esm/autoTitle.js","webpack://search-ui/./node_modules/@storybook/client-api/dist/esm/StoryStoreFacade.js","webpack://search-ui/./node_modules/@storybook/client-api/dist/esm/ClientApi.js","webpack://search-ui/./node_modules/@storybook/store/dist/esm/StoryIndexStore.js","webpack://search-ui/./node_modules/@storybook/store/dist/esm/args.js","webpack://search-ui/./node_modules/@storybook/store/dist/esm/GlobalsStore.js","webpack://search-ui/./node_modules/@storybook/store/dist/esm/csf/normalizeStory.js","webpack://search-ui/./node_modules/@storybook/store/dist/esm/csf/prepareStory.js","webpack://search-ui/./node_modules/@storybook/store/dist/esm/inferArgTypes.js","webpack://search-ui/./node_modules/@storybook/preview-web/dist/esm/Preview.js","webpack://search-ui/./node_modules/@storybook/preview-web/dist/esm/parseArgsParam.js","webpack://search-ui/./node_modules/@storybook/preview-web/dist/esm/WebView.js","webpack://search-ui/./node_modules/@storybook/preview-web/dist/esm/PreviewWeb.js","webpack://search-ui/./node_modules/@storybook/react/dist/config.mjs"],"sourcesContent":["import kebabcase from 'lodash.kebabcase';\nimport { normalize } from 'styled-normalize';\nimport { createGlobalStyle, css } from 'styled-components';\nimport { get } from '../utils/get';\nimport { breakpoints, headers, resolve } from '../utils/theme-helpers';\n\nconst createContainer = (key, value) => css`\n\t.container-${kebabcase(key)} {\n\t  max-width: ${resolve(value)};\n\t  margin-right: auto;\n\t  margin-left: auto;\n\t  // Overwrite the bootstrap padding\n\t  padding: 0;\n\t}\n`;\n\nconst BP = Object.entries(breakpoints).map(([key, value]) => createContainer(key, value));\nconst elements = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\nconst mobileHeaders = Object.keys(headers).filter(el => el.includes('-mobile'));\n\nconst cssNames = header => elements.includes(header) ? `${header}, .${header}` : `.${header}`; // @ts-expect-error\n\n\nconst mobileVersion = header => headers[`${header}-mobile`];\n\nconst hasMobileVersion = header => mobileHeaders.includes(`${header}-mobile`);\n\nexport const GlobalStyle = createGlobalStyle`\n\t${normalize}\n  \n  * {\n    box-sizing: border-box;\n  }\n  \n  body {\n    margin: 0;\n    font-family: ${get('typography.fontFamily.body')};\n    font-size: ${get('typography.fontSize.1')};\n    line-height: ${get('typography.lineHeight.default')};\n    font-weight: ${get('typography.fontWeight.regular')};\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n\n    color: ${get('elements.foreground.default')};\n  }\n  \n  .mono {\n    font-family: ${get('typography.fontFamily.mono')};\n    color: ${get('elements.foreground.subtle')};\n  }\n  \n  code, kbd, samp {\n    font-family: ${get('typography.fontFamily.mono')};\n\t  font-size: ${get(\"typography.fontSize.0\")};\n  }\n  \n\t${BP}\n\n    // Have these here so can be used anywhere without a component\n  ${Object.entries(headers).filter(([key, _]) => !mobileHeaders.includes(key)).map(bp => css`\n    ${cssNames(bp[0])} {\n      font-size: ${resolve(bp[1])};\n      font-weight: ${get('typography.fontWeight.semiBold')};\n      line-height: 1.2;\n      \n      // If their is a mobile version of the header force it here\n      ${hasMobileVersion(bp[0]) ? css`\n          @media (max-width: ${resolve(breakpoints.small)}) {\n            font-size: ${resolve(mobileVersion(bp[0]))};\n          }\n        ` : null}\n    }\n  `)}\n`;","/**\n * A remake of https://codepen.io/rebelchris/pen/jOMGweo\n *\n * Simple, and elegant.\n * */\nimport styled, { keyframes } from 'styled-components';\nimport { get } from '../../utils/get';\nimport { alpha } from '@advtr/tidy-core';\nconst toggle = keyframes`\n  0% {\n    left: 4px;\n  }\n\n  60% {\n    left: 4px;\n    width: 112px;\n  }\n\n  100% {\n    left: 104px;\n    width: 82px;\n  }\n`;\nconst reverse = keyframes`\n  0% {\n    left: 104px;\n    width: 82px;\n  }\n\n  60% {\n    left: 72px;\n    width: 112px;\n  }\n\n  100% {\n    left: 4px;\n  }\n`;\nexport const ToggleLabel = styled.label`\n  display: flex;\n  position: relative;\n\t\n  width: 200px;\n  height: 100px;\n\t\n  border-radius: 100px;\n  border: 5px solid ${get('elements.border.subtle')};\n\t\n  background: ${get('elements.canvas.overlay')};\n\n  transition: all 350ms ease-in;\n\t\n\t// Create the yellow on side of the switch\n\t&::before {\n    animation-name: ${reverse};\n    animation-duration: 350ms;\n    animation-fill-mode: forwards;\n    transition: all 350ms ease-in;\n    content: \"\";\n    width: 82px;\n    height: 82px;\n    border: 5px solid ${get('scheme.yellow.1')};\n    top: 4px;\n    left: 4px;\n    position: absolute;\n    border-radius: 82px;\n    background: ${get('scheme.yellow.2')};\n\t}\n\t\n\t&::after {\n    transition-delay: 0ms;\n    transition: all 250ms ease-in;\n    position: absolute;\n    content: \"\";\n    left: 143px;\n    top: 23px;\n    width: 10px;\n    height: 10px;\n    background: transparent;\n    border-radius: ${get('layout.border.radius.4')};\n    opacity: 0;\n\t}\n`;\nexport const ToggleCheckbox = styled.input`\n\tdisplay: none;\n\t\n\t&:checked { }\n\n  &:checked +${ToggleLabel}::before {\n    background: ${get('scheme.white')};\n    border-color: ${alpha(get('elements.border.muted'), 0.5)};\n    animation-name: ${toggle};\n    animation-duration: 350ms;\n    animation-fill-mode: forwards;\n  }\n\n  &:checked +${ToggleLabel}::after {\n    transition-delay: 350ms;\n    opacity: 1;\n    box-shadow: ${alpha(get('elements.border.muted'), 0.5)} -13px 0 0 2px, ${alpha(get('elements.border.muted'), 0.5)} -24px 14px 0 -2px;\n  }\n`;","import React, { useCallback, useMemo } from 'react';\nimport propTypes from 'prop-types';\nimport { useTheme } from '../../hooks/useTheme';\nimport Wrapper from './Wrapper';\nimport { ToggleLabel, ToggleCheckbox } from './components';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nexport const ThemeSwitch = ({\n  onClick\n}) => {\n  const theme = useTheme();\n  if (!theme) throw new Error('ThemeSwitch must be inside a <ThemeProvider> block');\n  const isChecked = useMemo(() => theme.colorScheme === 'dark', [theme]);\n  const handleClick = useCallback(e => {\n    theme.setColorScheme(prevState => {\n      return prevState == 'light' ? 'dark' : 'light';\n    });\n    onClick != null && onClick(e);\n  }, [onClick, theme]);\n  return /*#__PURE__*/_jsxs(Wrapper, {\n    children: [/*#__PURE__*/_jsx(ToggleCheckbox, {\n      \"aria-label\": \"theme-toggle\",\n      type: \"checkbox\",\n      id: \"theme-toggle\",\n      checked: isChecked,\n      onChange: handleClick\n    }), /*#__PURE__*/_jsx(ToggleLabel, {\n      htmlFor: \"theme-toggle\"\n    })]\n  });\n};\nThemeSwitch.propTypes = {\n  onClick: propTypes.func\n};","import styled from 'styled-components';\nimport { get } from '../../utils/get';\nconst Wrapper = styled.select`\n  background-color: ${get('elements.canvas.inset')};\n\tborder-radius: ${get('layout.border.radius.1')};\n\tcolor: ${get('elements.foreground.default')};\n  border-style: none;\n\t\n\tpadding: ${get('layout.spacing.1')} ${get('layout.spacing.2')};\n`;\nexport default Wrapper;","import React from 'react';\nimport propTypes from 'prop-types';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport class Option extends React.Component {\n  static propTypes = {\n    id: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.arrayOf(propTypes.string)]),\n    value: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.arrayOf(propTypes.string)]).isRequired\n  };\n\n  render() {\n    return /*#__PURE__*/_jsx(\"option\", {\n      value: this.props.id || this.props.value,\n      children: this.props.value\n    });\n  }\n\n}","import styled from 'styled-components';\nimport { get } from '../../utils/get'; // Add the very basic styling, just to set the tone\n\nconst Wrapper = styled.input`\n  width: 100%;\n\n  border-style: none;\n  color: ${get('elements.foreground.default')};\n\tbackground-color: ${get('elements.canvas.default')};\n\t\n\t// This could be adjusted to be a little nicer, maybe even using inherit,\n\t// but as a default input it will do\n\t&::placeholder {\n    color: ${get('elements.foreground.subtle')};\n\t}\n\t\n\t&:disabled {\n    color: ${get('elements.foreground.muted')};\n    background-color: ${get('elements.canvas.subtle')};\n\t}\n\n  &:focus {\n    outline: none;\n  }\n`;\nexport default Wrapper;","export function reducer(state, action) {\n  switch (action.type) {\n    case 'input':\n      return { ...state,\n        isEmpty: false\n      };\n\n    case 'blur':\n      return { ...state,\n        isFocussed: false\n      };\n\n    case 'focus':\n      return { ...state,\n        isFocussed: true\n      };\n\n    default:\n      throw new Error('Invalid Action ' + action);\n  }\n}","import styled from 'styled-components';\nimport * as _Input from '../_Input';\nimport { get } from '../../utils/get';\nimport { border as helper } from '../../utils/theme-helpers';\nconst Wrapper = styled.div`\n  position: relative;\n  width: 100%;\n\t\n\tdisplay: flex;\n  align-content: center;\n  align-items: center;\n\t\n  height: ${get('layout.spacing.7')};\n\n  color: ${get('elements.foreground.default')};\n  background-color: ${({\n  theme,\n  canvas\n}) => get(`elements.canvas.${canvas}`)({\n  theme\n})};\n\tbox-shadow: ${({\n  theme,\n  shadow\n}) => shadow && get(`elements.shadow.${shadow}`)({\n  theme\n})};\n  border: ${({\n  theme,\n  border\n}) => border && helper.custom(border)({\n  theme\n}) || 'none'};\n\t\n\tborder-radius: ${get('layout.border.radius.2')};\n\t\n\tpadding: 0 8px;\n\t\n\t${_Input.Wrapper} {\n\t\tpadding: 0 8px 0 8px;\n    background-color: inherit;\n\n    font-weight: ${get('typography.fontWeight.medium')};\n    line-height: 40px;\n\t}\n\t\n\t&:disabled {\n    color: ${get('elements.foreground.muted')};\n    background-color: ${get('elements.canvas.subtle')};\n\t}\n`;\nexport default Wrapper;","import styled, { css } from 'styled-components';\nimport { get } from '../../utils/get';\nimport { border, media } from '../../utils/theme-helpers';\nconst right = css`\n  padding-left: 8px;\n`;\nconst left = css`\n  padding-right: 8px;\n`;\n/**\n * This now works, not alone but when inside another div\n * */\n\nexport const IconContainer = styled.button`\n\t// Have to align is this way compared to how it was before\n  display: ${({\n  hide\n}) => hide ? 'none' : 'flex'};\n  align-items: center;\n\t\n  cursor: pointer;\n  height: ${get('layout.spacing.6')};\n  \n  // Pin it to the side\n\t${({\n  side\n}) => side === 'left' ? left : right};\n  \n  color: ${get('elements.foreground.default')};\n\tbackground-color: inherit;\n\tborder-style: none;\n  border-radius: 10px;\n  \n  & > svg {\n    width: ${get('layout.spacing.3')};\n    height: ${get('layout.spacing.3')};\n  }\n\t\n\t&:disabled {\n\t\tcursor: default;\n\t}\n\n  &:enabled > svg:hover {\n    color: ${get('elements.levels.active.foreground')};\n  }\n\n  &:disabled > svg {\n    cursor: default;\n    color: ${get('elements.foreground.muted')};\n  }\n`;\nexport const Listener = styled.kbd`\n\t// Have to align is this way compared to how it was before\n  display: ${({\n  hide\n}) => hide ? 'none' : 'flex'};\n  align-items: center;\n\t\n\tpadding: 2px;\n\t\n\t// For all larger screens make it slightly chunkier\n\t${media('small')} {\n\t\tpadding: 4px;\n\t}\n  \n\t// These can change\n  color: ${get('elements.foreground.default')};\n\tbackground-color: ${get('elements.canvas.overlay')};\n\tborder: ${border.style};\n  border-radius: ${border.default}\n`;","/**\n * A bunch of helpers that are added/created in GlobalStyle, so we can use classnames too,\n * or resolve to something so we can just use `${helper.header.h00}`\n * */\nimport { get } from './get';\nexport const resolve = fn => ctx => typeof fn === 'function' ? fn(ctx) : fn;\nexport const breakpoints = {\n  small: '544px',\n  medium: '768px',\n  large: '1012px',\n  extraLarge: '1280px'\n};\nexport function media(breakpoint) {\n  return `@media (min-width: ${breakpoints[breakpoint]})`;\n} // Heading sizes - mobile\n// h4-h6 remain the same size on both mobile & desktop\n\nconst mobileHeaders = {\n  'h00-mobile': get('typography.fontSize.6'),\n  'h0-mobile': get('typography.fontSize.5'),\n  'h1-mobile': '26px',\n  'h2-mobile': '22px',\n  'h3-mobile': '18px'\n};\nexport const headers = { ...mobileHeaders,\n  h000: '64px',\n  h00: get('typography.fontSize.7'),\n  h0: get('typography.fontSize.6'),\n  h1: get('typography.fontSize.5'),\n  h2: get('typography.fontSize.4'),\n  h3: get('typography.fontSize.3'),\n  h4: get('typography.fontSize.2'),\n  h5: get('typography.fontSize.1'),\n  h6: get('typography.fontSize.0')\n};\nexport const border = {\n  default: get('layout.border.radius.1'),\n  style: ctx => `1px solid ${get('elements.border.default')(ctx)}`,\n  custom: style => ctx => `1px solid ${get(`elements.border.${style}`)(ctx)}`,\n  circular: get('layout.border.radius.4')\n};","import React, { forwardRef, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport Wrapper from './Wrapper';\nimport { _Input } from '../_Input';\nimport { IconContainer } from './components';\nimport { useListener } from './actions';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nexport const Input = /*#__PURE__*/forwardRef(({\n  Icon,\n  hide,\n  side,\n  shadow,\n  canvas,\n  border,\n  listener,\n  onClick,\n  onBlur,\n  onFocus,\n  children,\n  ...props\n}, ref) => {\n  const [createListener, handleFocus, handleBlur] = useListener({\n    enabled: listener,\n    onFocus,\n    onBlur,\n    ref\n  });\n  /**\n  * Handle the Icons\n  * */\n\n  const child = useMemo(() => // First check for a children, if not check whether it's an icon, if not return null\n  children != null ? children : Icon != null ? /*#__PURE__*/_jsx(Icon, {\n    onClick: onClick,\n    disabled: props.disabled,\n    \"aria-label\": \"input-icon\"\n  }) : null, [Icon, children, onClick, props.disabled]);\n  const createIcon = useMemo(() => child != null && /*#__PURE__*/_jsx(IconContainer, {\n    hide: hide,\n    side: side,\n    disabled: props.disabled,\n    children: child\n  }), [child, hide, side, props.disabled]);\n  return /*#__PURE__*/_jsxs(Wrapper, {\n    shadow: shadow,\n    canvas: canvas,\n    border: border,\n    children: [side === 'left' && createIcon || createListener, /*#__PURE__*/_jsx(_Input, {\n      onBlur: handleBlur,\n      onFocus: handleFocus,\n      ...props,\n      ref: ref\n    }), side === 'right' && createIcon || createListener]\n  });\n});\nInput.defaultProps = {\n  side: 'left',\n  hide: false,\n  disabled: false,\n  listener: true,\n  placeholder: 'Input...',\n  shadow: null,\n  canvas: 'default',\n  border: 'default'\n};\nInput.propTypes = {\n  // _Input Props\n  disabled: PropTypes.bool,\n  onInput: PropTypes.func,\n  onFocus: PropTypes.func,\n  onBlur: PropTypes.func,\n  className: PropTypes.string,\n  value: PropTypes.string,\n  placeholder: PropTypes.string,\n  'aria-label': PropTypes.string,\n  // IconContainer Props\n  hide: PropTypes.bool,\n  side: PropTypes.oneOf(['left', 'right']),\n  // IconProps Props\n  onClick: PropTypes.func,\n  listener: PropTypes.bool,\n  hideListener: PropTypes.bool,\n  // @ts-expect-error\n  Icon: PropTypes.elementType,\n  children: PropTypes.element,\n  // InputProps Props\n  // @ts-expect-error\n  canvas: PropTypes.oneOf(['default', 'inset', 'overlay']),\n  shadow: PropTypes.oneOf(['small', 'medium', 'large', 'extraLarge']),\n  border: PropTypes.oneOf(['default', 'subtle', 'muted'])\n};","// Based on http://backbonejs.org/docs/backbone.html#section-164\nimport global from 'global';\nimport { useEffect, makeDecorator } from '@storybook/addons';\nimport deprecate from 'util-deprecate';\nimport { dedent } from 'ts-dedent';\nimport { actions } from './actions';\nimport { PARAM_KEY } from '../constants';\nconst {\n  document,\n  Element\n} = global;\nconst delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\nconst isIE = Element != null && !Element.prototype.matches;\nconst matchesMethod = isIE ? 'msMatchesSelector' : 'matches';\n\nconst hasMatchInAncestry = (element, selector) => {\n  if (element[matchesMethod](selector)) {\n    return true;\n  }\n\n  const parent = element.parentElement;\n\n  if (!parent) {\n    return false;\n  }\n\n  return hasMatchInAncestry(parent, selector);\n};\n\nconst createHandlers = (actionsFn, ...handles) => {\n  const actionsObject = actionsFn(...handles);\n  return Object.entries(actionsObject).map(([key, action]) => {\n    const [_, eventName, selector] = key.match(delegateEventSplitter) || [];\n    return {\n      eventName,\n      handler: e => {\n        if (!selector || hasMatchInAncestry(e.target, selector)) {\n          action(e);\n        }\n      }\n    };\n  });\n};\n\nconst applyEventHandlers = deprecate((actionsFn, ...handles) => {\n  const root = document && document.getElementById('root');\n  useEffect(() => {\n    if (root != null) {\n      const handlers = createHandlers(actionsFn, ...handles);\n      handlers.forEach(({\n        eventName,\n        handler\n      }) => root.addEventListener(eventName, handler));\n      return () => handlers.forEach(({\n        eventName,\n        handler\n      }) => root.removeEventListener(eventName, handler));\n    }\n\n    return undefined;\n  }, [root, actionsFn, handles]);\n}, dedent`\n    withActions(options) is deprecated, please configure addon-actions using the addParameter api:\n\n    addParameters({\n      actions: {\n        handles: options\n      },\n    });\n  `);\n\nconst applyDeprecatedOptions = (actionsFn, options) => {\n  if (options) {\n    applyEventHandlers(actionsFn, options);\n  }\n};\n\nexport const withActions = makeDecorator({\n  name: 'withActions',\n  parameterName: PARAM_KEY,\n  skipIfNoParametersOrOptions: true,\n  wrapper: (getStory, context, {\n    parameters,\n    options\n  }) => {\n    applyDeprecatedOptions(actions, options);\n    if (parameters && parameters.handles) applyEventHandlers(actions, ...parameters.handles);\n    return getStory(context);\n  }\n});","import { withBackground } from './decorators/withBackground';\nimport { withGrid } from './decorators/withGrid';\nexport const decorators = [withGrid, withBackground];\nexport const parameters = {\n  backgrounds: {\n    grid: {\n      cellSize: 20,\n      opacity: 0.5,\n      cellAmount: 5\n    },\n    values: [{\n      name: 'light',\n      value: '#F8F8F8'\n    }, {\n      name: 'dark',\n      value: '#333333'\n    }]\n  }\n};","import global from 'global';\nimport { dedent } from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nconst {\n  document,\n  window\n} = global;\nexport const isReduceMotionEnabled = () => {\n  const prefersReduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)');\n  return prefersReduceMotion.matches;\n};\nexport const getBackgroundColorByName = (currentSelectedValue, backgrounds = [], defaultName) => {\n  if (currentSelectedValue === 'transparent') {\n    return 'transparent';\n  }\n\n  if (backgrounds.find(background => background.value === currentSelectedValue)) {\n    return currentSelectedValue;\n  }\n\n  const defaultBackground = backgrounds.find(background => background.name === defaultName);\n\n  if (defaultBackground) {\n    return defaultBackground.value;\n  }\n\n  if (defaultName) {\n    const availableColors = backgrounds.map(background => background.name).join(', ');\n    logger.warn(dedent`\n        Backgrounds Addon: could not find the default color \"${defaultName}\".\n        These are the available colors for your story based on your configuration:\n        ${availableColors}.\n      `);\n  }\n\n  return 'transparent';\n};\nexport const clearStyles = selector => {\n  const selectors = Array.isArray(selector) ? selector : [selector];\n  selectors.forEach(clearStyle);\n};\n\nconst clearStyle = selector => {\n  const element = document.getElementById(selector);\n\n  if (element) {\n    element.parentElement.removeChild(element);\n  }\n};\n\nexport const addGridStyle = (selector, css) => {\n  const existingStyle = document.getElementById(selector);\n\n  if (existingStyle) {\n    if (existingStyle.innerHTML !== css) {\n      existingStyle.innerHTML = css;\n    }\n  } else {\n    const style = document.createElement('style');\n    style.setAttribute('id', selector);\n    style.innerHTML = css;\n    document.head.appendChild(style);\n  }\n};\nexport const addBackgroundStyle = (selector, css, storyId) => {\n  const existingStyle = document.getElementById(selector);\n\n  if (existingStyle) {\n    if (existingStyle.innerHTML !== css) {\n      existingStyle.innerHTML = css;\n    }\n  } else {\n    const style = document.createElement('style');\n    style.setAttribute('id', selector);\n    style.innerHTML = css;\n    const gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : ''}`; // If grids already exist, we want to add the style tag BEFORE it so the background doesn't override grid\n\n    const existingGridStyle = document.getElementById(gridStyleSelector);\n\n    if (existingGridStyle) {\n      existingGridStyle.parentElement.insertBefore(style, existingGridStyle);\n    } else {\n      document.head.appendChild(style);\n    }\n  }\n};","import { dedent } from 'ts-dedent';\n/*\n  From pesticide v1.3.0 . @mrmrs . MIT\n*/\n\nexport default function outlineCSS(selector) {\n  return dedent\n  /* css */\n  `\n    ${selector} body {\n      outline: 1px solid #2980b9 !important;\n    }\n\n    ${selector} article {\n      outline: 1px solid #3498db !important;\n    }\n\n    ${selector} nav {\n      outline: 1px solid #0088c3 !important;\n    }\n\n    ${selector} aside {\n      outline: 1px solid #33a0ce !important;\n    }\n\n    ${selector} section {\n      outline: 1px solid #66b8da !important;\n    }\n\n    ${selector} header {\n      outline: 1px solid #99cfe7 !important;\n    }\n\n    ${selector} footer {\n      outline: 1px solid #cce7f3 !important;\n    }\n\n    ${selector} h1 {\n      outline: 1px solid #162544 !important;\n    }\n\n    ${selector} h2 {\n      outline: 1px solid #314e6e !important;\n    }\n\n    ${selector} h3 {\n      outline: 1px solid #3e5e85 !important;\n    }\n\n    ${selector} h4 {\n      outline: 1px solid #449baf !important;\n    }\n\n    ${selector} h5 {\n      outline: 1px solid #c7d1cb !important;\n    }\n\n    ${selector} h6 {\n      outline: 1px solid #4371d0 !important;\n    }\n\n    ${selector} main {\n      outline: 1px solid #2f4f90 !important;\n    }\n\n    ${selector} address {\n      outline: 1px solid #1a2c51 !important;\n    }\n\n    ${selector} div {\n      outline: 1px solid #036cdb !important;\n    }\n\n    ${selector} p {\n      outline: 1px solid #ac050b !important;\n    }\n\n    ${selector} hr {\n      outline: 1px solid #ff063f !important;\n    }\n\n    ${selector} pre {\n      outline: 1px solid #850440 !important;\n    }\n\n    ${selector} blockquote {\n      outline: 1px solid #f1b8e7 !important;\n    }\n\n    ${selector} ol {\n      outline: 1px solid #ff050c !important;\n    }\n\n    ${selector} ul {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${selector} li {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${selector} dl {\n      outline: 1px solid #fd3427 !important;\n    }\n\n    ${selector} dt {\n      outline: 1px solid #ff0043 !important;\n    }\n\n    ${selector} dd {\n      outline: 1px solid #e80174 !important;\n    }\n\n    ${selector} figure {\n      outline: 1px solid #ff00bb !important;\n    }\n\n    ${selector} figcaption {\n      outline: 1px solid #bf0032 !important;\n    }\n\n    ${selector} table {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${selector} caption {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${selector} thead {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${selector} tbody {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${selector} tfoot {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${selector} tr {\n      outline: 1px solid #86c0b2 !important;\n    }\n\n    ${selector} th {\n      outline: 1px solid #a1e7d6 !important;\n    }\n\n    ${selector} td {\n      outline: 1px solid #3f5a54 !important;\n    }\n\n    ${selector} col {\n      outline: 1px solid #6c9a8f !important;\n    }\n\n    ${selector} colgroup {\n      outline: 1px solid #6c9a9d !important;\n    }\n\n    ${selector} button {\n      outline: 1px solid #da8301 !important;\n    }\n\n    ${selector} datalist {\n      outline: 1px solid #c06000 !important;\n    }\n\n    ${selector} fieldset {\n      outline: 1px solid #d95100 !important;\n    }\n\n    ${selector} form {\n      outline: 1px solid #d23600 !important;\n    }\n\n    ${selector} input {\n      outline: 1px solid #fca600 !important;\n    }\n\n    ${selector} keygen {\n      outline: 1px solid #b31e00 !important;\n    }\n\n    ${selector} label {\n      outline: 1px solid #ee8900 !important;\n    }\n\n    ${selector} legend {\n      outline: 1px solid #de6d00 !important;\n    }\n\n    ${selector} meter {\n      outline: 1px solid #e8630c !important;\n    }\n\n    ${selector} optgroup {\n      outline: 1px solid #b33600 !important;\n    }\n\n    ${selector} option {\n      outline: 1px solid #ff8a00 !important;\n    }\n\n    ${selector} output {\n      outline: 1px solid #ff9619 !important;\n    }\n\n    ${selector} progress {\n      outline: 1px solid #e57c00 !important;\n    }\n\n    ${selector} select {\n      outline: 1px solid #e26e0f !important;\n    }\n\n    ${selector} textarea {\n      outline: 1px solid #cc5400 !important;\n    }\n\n    ${selector} details {\n      outline: 1px solid #33848f !important;\n    }\n\n    ${selector} summary {\n      outline: 1px solid #60a1a6 !important;\n    }\n\n    ${selector} command {\n      outline: 1px solid #438da1 !important;\n    }\n\n    ${selector} menu {\n      outline: 1px solid #449da6 !important;\n    }\n\n    ${selector} del {\n      outline: 1px solid #bf0000 !important;\n    }\n\n    ${selector} ins {\n      outline: 1px solid #400000 !important;\n    }\n\n    ${selector} img {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${selector} iframe {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${selector} embed {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${selector} object {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${selector} param {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${selector} video {\n      outline: 1px solid #6ee866 !important;\n    }\n\n    ${selector} audio {\n      outline: 1px solid #027353 !important;\n    }\n\n    ${selector} source {\n      outline: 1px solid #012426 !important;\n    }\n\n    ${selector} canvas {\n      outline: 1px solid #a2f570 !important;\n    }\n\n    ${selector} track {\n      outline: 1px solid #59a600 !important;\n    }\n\n    ${selector} map {\n      outline: 1px solid #7be500 !important;\n    }\n\n    ${selector} area {\n      outline: 1px solid #305900 !important;\n    }\n\n    ${selector} a {\n      outline: 1px solid #ff62ab !important;\n    }\n\n    ${selector} em {\n      outline: 1px solid #800b41 !important;\n    }\n\n    ${selector} strong {\n      outline: 1px solid #ff1583 !important;\n    }\n\n    ${selector} i {\n      outline: 1px solid #803156 !important;\n    }\n\n    ${selector} b {\n      outline: 1px solid #cc1169 !important;\n    }\n\n    ${selector} u {\n      outline: 1px solid #ff0430 !important;\n    }\n\n    ${selector} s {\n      outline: 1px solid #f805e3 !important;\n    }\n\n    ${selector} small {\n      outline: 1px solid #d107b2 !important;\n    }\n\n    ${selector} abbr {\n      outline: 1px solid #4a0263 !important;\n    }\n\n    ${selector} q {\n      outline: 1px solid #240018 !important;\n    }\n\n    ${selector} cite {\n      outline: 1px solid #64003c !important;\n    }\n\n    ${selector} dfn {\n      outline: 1px solid #b4005a !important;\n    }\n\n    ${selector} sub {\n      outline: 1px solid #dba0c8 !important;\n    }\n\n    ${selector} sup {\n      outline: 1px solid #cc0256 !important;\n    }\n\n    ${selector} time {\n      outline: 1px solid #d6606d !important;\n    }\n\n    ${selector} code {\n      outline: 1px solid #e04251 !important;\n    }\n\n    ${selector} kbd {\n      outline: 1px solid #5e001f !important;\n    }\n\n    ${selector} samp {\n      outline: 1px solid #9c0033 !important;\n    }\n\n    ${selector} var {\n      outline: 1px solid #d90047 !important;\n    }\n\n    ${selector} mark {\n      outline: 1px solid #ff0053 !important;\n    }\n\n    ${selector} bdi {\n      outline: 1px solid #bf3668 !important;\n    }\n\n    ${selector} bdo {\n      outline: 1px solid #6f1400 !important;\n    }\n\n    ${selector} ruby {\n      outline: 1px solid #ff7b93 !important;\n    }\n\n    ${selector} rt {\n      outline: 1px solid #ff2f54 !important;\n    }\n\n    ${selector} rp {\n      outline: 1px solid #803e49 !important;\n    }\n\n    ${selector} span {\n      outline: 1px solid #cc2643 !important;\n    }\n\n    ${selector} br {\n      outline: 1px solid #db687d !important;\n    }\n\n    ${selector} wbr {\n      outline: 1px solid #db175b !important;\n    }`;\n}","import \"core-js/modules/web.immediate.js\";\n/// <reference types=\"node\" />\nimport deprecate from 'util-deprecate';\nimport { dedent } from 'ts-dedent';\n\nconst generateRandomId = () => {\n  // generates a random 13 character string\n  return Math.random().toString(16).slice(2);\n};\n\nexport class Channel {\n  constructor({\n    transport,\n    async = false\n  } = {}) {\n    this.isAsync = void 0;\n    this.sender = generateRandomId();\n    this.events = {};\n    this.data = {};\n    this.transport = void 0;\n    this.addPeerListener = deprecate((eventName, listener) => {\n      this.addListener(eventName, listener);\n    }, dedent`\n      channel.addPeerListener is deprecated\n    `);\n    this.isAsync = async;\n\n    if (transport) {\n      this.transport = transport;\n      this.transport.setHandler(event => this.handleEvent(event));\n    }\n  }\n\n  get hasTransport() {\n    return !!this.transport;\n  }\n\n  addListener(eventName, listener) {\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(listener);\n  }\n\n  emit(eventName, ...args) {\n    const event = {\n      type: eventName,\n      args,\n      from: this.sender\n    };\n    let options = {};\n\n    if (args.length >= 1 && args[0] && args[0].options) {\n      options = args[0].options;\n    }\n\n    const handler = () => {\n      if (this.transport) {\n        this.transport.send(event, options);\n      }\n\n      this.handleEvent(event);\n    };\n\n    if (this.isAsync) {\n      // todo I'm not sure how to test this\n      setImmediate(handler);\n    } else {\n      handler();\n    }\n  }\n\n  last(eventName) {\n    return this.data[eventName];\n  }\n\n  eventNames() {\n    return Object.keys(this.events);\n  }\n\n  listenerCount(eventName) {\n    const listeners = this.listeners(eventName);\n    return listeners ? listeners.length : 0;\n  }\n\n  listeners(eventName) {\n    const listeners = this.events[eventName];\n    return listeners || undefined;\n  }\n\n  once(eventName, listener) {\n    const onceListener = this.onceListener(eventName, listener);\n    this.addListener(eventName, onceListener);\n  }\n\n  removeAllListeners(eventName) {\n    if (!eventName) {\n      this.events = {};\n    } else if (this.events[eventName]) {\n      delete this.events[eventName];\n    }\n  }\n\n  removeListener(eventName, listener) {\n    const listeners = this.listeners(eventName);\n\n    if (listeners) {\n      this.events[eventName] = listeners.filter(l => l !== listener);\n    }\n  }\n\n  on(eventName, listener) {\n    this.addListener(eventName, listener);\n  }\n\n  off(eventName, listener) {\n    this.removeListener(eventName, listener);\n  }\n\n  handleEvent(event) {\n    const listeners = this.listeners(event.type);\n\n    if (listeners && listeners.length) {\n      listeners.forEach(fn => {\n        fn.apply(event, event.args);\n      });\n    }\n\n    this.data[event.type] = event.args;\n  }\n\n  onceListener(eventName, listener) {\n    const onceListener = (...args) => {\n      this.removeListener(eventName, onceListener);\n      return listener(...args);\n    };\n\n    return onceListener;\n  }\n\n}\nexport default Channel;","import slash from 'slash';\nimport { dedent } from 'ts-dedent';\nimport { once } from '@storybook/client-logger'; // FIXME: types duplicated type from `core-common', to be\n// removed when we remove v6 back-compat.\n\nconst stripExtension = path => {\n  let parts = [...path];\n  const last = parts[parts.length - 1];\n  const dotIndex = last.indexOf('.');\n  const stripped = dotIndex > 0 ? last.substr(0, dotIndex) : last;\n  parts[parts.length - 1] = stripped;\n  const [first, ...rest] = parts;\n\n  if (first === '') {\n    parts = rest;\n  }\n\n  return parts;\n};\n\nconst indexRe = /^index$/i; // deal with files like \"atoms/button/{button,index}.stories.js\"\n\nconst removeRedundantFilename = paths => {\n  let prevVal;\n  return paths.filter((val, index) => {\n    if (index === paths.length - 1 && (val === prevVal || indexRe.test(val))) {\n      return false;\n    }\n\n    prevVal = val;\n    return true;\n  });\n};\n/**\n * Combines path parts together, without duplicating separators (slashes).  Used instead of `path.join`\n * because this code runs in the browser.\n *\n * @param paths array of paths to join together.\n * @returns joined path string, with single '/' between parts\n */\n\n\nfunction pathJoin(paths) {\n  const slashes = new RegExp('/{1,}', 'g');\n  return paths.join('/').replace(slashes, '/');\n}\n\nexport const userOrAutoTitleFromSpecifier = (fileName, entry, userTitle) => {\n  const {\n    directory,\n    importPathMatcher,\n    titlePrefix = ''\n  } = entry || {}; // On Windows, backslashes are used in paths, which can cause problems here\n  // slash makes sure we always handle paths with unix-style forward slash\n\n  if (typeof fileName === 'number') {\n    once.warn(dedent`\n      CSF Auto-title received a numeric fileName. This typically happens when\n      webpack is mis-configured in production mode. To force webpack to produce\n      filenames, set optimization.moduleIds = \"named\" in your webpack config.\n    `);\n  }\n\n  const normalizedFileName = slash(String(fileName));\n\n  if (importPathMatcher.exec(normalizedFileName)) {\n    if (!userTitle) {\n      const suffix = normalizedFileName.replace(directory, '');\n      const titleAndSuffix = slash(pathJoin([titlePrefix, suffix]));\n      let path = titleAndSuffix.split('/');\n      path = stripExtension(path);\n      path = removeRedundantFilename(path);\n      return path.join('/');\n    }\n\n    if (!titlePrefix) {\n      return userTitle;\n    }\n\n    return slash(pathJoin([titlePrefix, userTitle]));\n  }\n\n  return undefined;\n};\nexport const userOrAutoTitle = (fileName, storiesEntries, userTitle) => {\n  for (let i = 0; i < storiesEntries.length; i += 1) {\n    const title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i], userTitle);\n    if (title) return title;\n  }\n\n  return userTitle || undefined;\n};","const _excluded = [\"default\", \"__namedExportsOrder\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* eslint-disable no-underscore-dangle */\nimport global from 'global';\nimport { dedent } from 'ts-dedent';\nimport { SynchronousPromise } from 'synchronous-promise';\nimport { toId, isExportStory, storyNameFromExport } from '@storybook/csf';\nimport { userOrAutoTitle, sortStoriesV6 } from '@storybook/store';\nimport { logger } from '@storybook/client-logger';\nimport deprecate from 'util-deprecate';\nconst docs2Warning = deprecate(() => {}, `You cannot use \\`.mdx\\` files without using \\`storyStoreV7\\`. Consider upgrading to the new store.`);\nexport class StoryStoreFacade {\n  constructor() {\n    this.projectAnnotations = void 0;\n    this.entries = void 0;\n    this.csfExports = void 0;\n    this.projectAnnotations = {\n      loaders: [],\n      decorators: [],\n      parameters: {},\n      argsEnhancers: [],\n      argTypesEnhancers: [],\n      args: {},\n      argTypes: {}\n    };\n    this.entries = {};\n    this.csfExports = {};\n  } // This doesn't actually import anything because the client-api loads fully\n  // on startup, but this is a shim after all.\n\n\n  importFn(path) {\n    return SynchronousPromise.resolve().then(() => {\n      const moduleExports = this.csfExports[path];\n      if (!moduleExports) throw new Error(`Unknown path: ${path}`);\n      return moduleExports;\n    });\n  }\n\n  getStoryIndex(store) {\n    const fileNameOrder = Object.keys(this.csfExports);\n    const storySortParameter = this.projectAnnotations.parameters?.options?.storySort;\n    const storyEntries = Object.entries(this.entries); // Add the kind parameters and global parameters to each entry\n\n    const sortableV6 = storyEntries.map(([storyId, {\n      importPath\n    }]) => {\n      const exports = this.csfExports[importPath];\n      const csfFile = store.processCSFFileWithCache(exports, importPath, exports.default.title);\n      return [storyId, store.storyFromCSFFile({\n        storyId,\n        csfFile\n      }), csfFile.meta.parameters, this.projectAnnotations.parameters];\n    }); // NOTE: the sortStoriesV6 version returns the v7 data format. confusing but more convenient!\n\n    let sortedV7;\n\n    try {\n      sortedV7 = sortStoriesV6(sortableV6, storySortParameter, fileNameOrder);\n    } catch (err) {\n      if (typeof storySortParameter === 'function') {\n        throw new Error(dedent`\n          Error sorting stories with sort parameter ${storySortParameter}:\n\n          > ${err.message}\n          \n          Are you using a V7-style sort function in V6 compatibility mode?\n          \n          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort\n        `);\n      }\n\n      throw err;\n    }\n\n    const entries = sortedV7.reduce((acc, s) => {\n      // We use the original entry we stored in `this.stories` because it is possible that the CSF file itself\n      // exports a `parameters.fileName` which can be different and mess up our `importFn`.\n      // In fact, in Storyshots there is a Jest transformer that does exactly that.\n      // NOTE: this doesn't actually change the story object, just the index.\n      acc[s.id] = this.entries[s.id];\n      return acc;\n    }, {});\n    return {\n      v: 4,\n      entries\n    };\n  }\n\n  clearFilenameExports(fileName) {\n    if (!this.csfExports[fileName]) {\n      return;\n    } // Clear this module's stories from the storyList and existing exports\n\n\n    Object.entries(this.entries).forEach(([id, {\n      importPath\n    }]) => {\n      if (importPath === fileName) {\n        delete this.entries[id];\n      }\n    }); // We keep this as an empty record so we can use it to maintain component order\n\n    this.csfExports[fileName] = {};\n  } // NOTE: we could potentially share some of this code with the stories.json generation\n\n\n  addStoriesFromExports(fileName, fileExports) {\n    if (fileName.match(/\\.mdx$/) && !fileName.match(/\\.stories\\.mdx$/)) {\n      docs2Warning();\n      return;\n    } // if the export haven't changed since last time we added them, this is a no-op\n\n\n    if (this.csfExports[fileName] === fileExports) {\n      return;\n    } // OTOH, if they have changed, let's clear them out first\n\n\n    this.clearFilenameExports(fileName);\n\n    const {\n      default: defaultExport,\n      __namedExportsOrder\n    } = fileExports,\n          namedExports = _objectWithoutPropertiesLoose(fileExports, _excluded); // eslint-disable-next-line prefer-const\n\n\n    let {\n      id: componentId,\n      title\n    } = defaultExport || {};\n    const specifiers = (global.STORIES || []).map(specifier => Object.assign({}, specifier, {\n      importPathMatcher: new RegExp(specifier.importPathMatcher)\n    }));\n    title = userOrAutoTitle(fileName, specifiers, title);\n\n    if (!title) {\n      logger.info(`Unexpected default export without title in '${fileName}': ${JSON.stringify(fileExports.default)}`);\n      return;\n    }\n\n    this.csfExports[fileName] = Object.assign({}, fileExports, {\n      default: Object.assign({}, defaultExport, {\n        title\n      })\n    });\n    let sortedExports = namedExports; // prefer a user/loader provided `__namedExportsOrder` array if supplied\n    // we do this as es module exports are always ordered alphabetically\n    // see https://github.com/storybookjs/storybook/issues/9136\n\n    if (Array.isArray(__namedExportsOrder)) {\n      sortedExports = {};\n\n      __namedExportsOrder.forEach(name => {\n        const namedExport = namedExports[name];\n        if (namedExport) sortedExports[name] = namedExport;\n      });\n    }\n\n    Object.entries(sortedExports).filter(([key]) => isExportStory(key, defaultExport)).forEach(([key, storyExport]) => {\n      const exportName = storyNameFromExport(key);\n      const id = storyExport.parameters?.__id || toId(componentId || title, exportName);\n      const name = typeof storyExport !== 'function' && storyExport.name || storyExport.storyName || storyExport.story?.name || exportName;\n      this.entries[id] = {\n        id,\n        name,\n        title,\n        importPath: fileName,\n        type: 'story'\n      };\n    });\n  }\n\n}","const _excluded = [\"globals\", \"globalTypes\"],\n      _excluded2 = [\"decorators\", \"loaders\", \"component\", \"args\", \"argTypes\"],\n      _excluded3 = [\"component\", \"args\", \"argTypes\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/// <reference types=\"webpack-env\" />\nimport deprecate from 'util-deprecate';\nimport { dedent } from 'ts-dedent';\nimport global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport { toId, sanitize } from '@storybook/csf';\nimport { combineParameters, normalizeInputTypes } from '@storybook/store';\nimport { StoryStoreFacade } from './StoryStoreFacade';\n// ClientApi (and StoreStore) are really singletons. However they are not created until the\n// relevant framework instanciates them via `start.js`. The good news is this happens right away.\nlet singleton;\nconst warningAlternatives = {\n  addDecorator: `Instead, use \\`export const decorators = [];\\` in your \\`preview.js\\`.`,\n  addParameters: `Instead, use \\`export const parameters = {};\\` in your \\`preview.js\\`.`,\n  addLoaders: `Instead, use \\`export const loaders = [];\\` in your \\`preview.js\\`.`\n};\n\nconst warningMessage = method => deprecate(() => {}, dedent`\n  \\`${method}\\` is deprecated, and will be removed in Storybook 7.0.\n\n  ${warningAlternatives[method]}\n\n  Read more at https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-addparameters-and-adddecorator).`);\n\nconst warnings = {\n  addDecorator: warningMessage('addDecorator'),\n  addParameters: warningMessage('addParameters'),\n  addLoaders: warningMessage('addLoaders')\n};\n\nconst checkMethod = (method, deprecationWarning) => {\n  if (global.FEATURES?.storyStoreV7) {\n    throw new Error(dedent`You cannot use \\`${method}\\` with the new Story Store.\n      \n      ${warningAlternatives[method]}`);\n  }\n\n  if (!singleton) {\n    throw new Error(`Singleton client API not yet initialized, cannot call \\`${method}\\`.`);\n  }\n\n  if (deprecationWarning) {\n    warnings[method]();\n  }\n};\n\nexport const addDecorator = (decorator, deprecationWarning = true) => {\n  checkMethod('addDecorator', deprecationWarning);\n  singleton.addDecorator(decorator);\n};\nexport const addParameters = (parameters, deprecationWarning = true) => {\n  checkMethod('addParameters', deprecationWarning);\n  singleton.addParameters(parameters);\n};\nexport const addLoader = (loader, deprecationWarning = true) => {\n  checkMethod('addLoader', deprecationWarning);\n  singleton.addLoader(loader);\n};\nexport const addArgs = args => {\n  checkMethod('addArgs', false);\n  singleton.addArgs(args);\n};\nexport const addArgTypes = argTypes => {\n  checkMethod('addArgTypes', false);\n  singleton.addArgTypes(argTypes);\n};\nexport const addArgsEnhancer = enhancer => {\n  checkMethod('addArgsEnhancer', false);\n  singleton.addArgsEnhancer(enhancer);\n};\nexport const addArgTypesEnhancer = enhancer => {\n  checkMethod('addArgTypesEnhancer', false);\n  singleton.addArgTypesEnhancer(enhancer);\n};\nexport const getGlobalRender = () => {\n  checkMethod('getGlobalRender', false);\n  return singleton.facade.projectAnnotations.render;\n};\nexport const setGlobalRender = render => {\n  checkMethod('setGlobalRender', false);\n  singleton.facade.projectAnnotations.render = render;\n};\nconst invalidStoryTypes = new Set(['string', 'number', 'boolean', 'symbol']);\nexport class ClientApi {\n  // If we don't get passed modules so don't know filenames, we can\n  // just use numeric indexes\n  constructor({\n    storyStore\n  } = {}) {\n    this.facade = void 0;\n    this.storyStore = void 0;\n    this.addons = void 0;\n    this.onImportFnChanged = void 0;\n    this.lastFileName = 0;\n    this.setAddon = deprecate(addon => {\n      this.addons = Object.assign({}, this.addons, addon);\n    }, dedent`\n      \\`setAddon\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-setaddon\n    `);\n\n    this.addDecorator = decorator => {\n      this.facade.projectAnnotations.decorators.push(decorator);\n    };\n\n    this.clearDecorators = deprecate(() => {\n      this.facade.projectAnnotations.decorators = [];\n    }, dedent`\n      \\`clearDecorators\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-cleardecorators\n    `);\n\n    this.addParameters = _ref => {\n      let {\n        globals,\n        globalTypes\n      } = _ref,\n          parameters = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      this.facade.projectAnnotations.parameters = combineParameters(this.facade.projectAnnotations.parameters, parameters);\n\n      if (globals) {\n        this.facade.projectAnnotations.globals = Object.assign({}, this.facade.projectAnnotations.globals, globals);\n      }\n\n      if (globalTypes) {\n        this.facade.projectAnnotations.globalTypes = Object.assign({}, this.facade.projectAnnotations.globalTypes, normalizeInputTypes(globalTypes));\n      }\n    };\n\n    this.addLoader = loader => {\n      this.facade.projectAnnotations.loaders.push(loader);\n    };\n\n    this.addArgs = args => {\n      this.facade.projectAnnotations.args = Object.assign({}, this.facade.projectAnnotations.args, args);\n    };\n\n    this.addArgTypes = argTypes => {\n      this.facade.projectAnnotations.argTypes = Object.assign({}, this.facade.projectAnnotations.argTypes, normalizeInputTypes(argTypes));\n    };\n\n    this.addArgsEnhancer = enhancer => {\n      this.facade.projectAnnotations.argsEnhancers.push(enhancer);\n    };\n\n    this.addArgTypesEnhancer = enhancer => {\n      this.facade.projectAnnotations.argTypesEnhancers.push(enhancer);\n    };\n\n    this.storiesOf = (kind, m) => {\n      if (!kind && typeof kind !== 'string') {\n        throw new Error('Invalid or missing kind provided for stories, should be a string');\n      }\n\n      if (!m) {\n        logger.warn(`Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`);\n      }\n\n      if (m) {\n        const proto = Object.getPrototypeOf(m);\n\n        if (proto.exports && proto.exports.default) {\n          // FIXME: throw an error in SB6.0\n          logger.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`);\n        }\n      } // eslint-disable-next-line no-plusplus\n\n\n      const baseFilename = m && m.id ? `${m.id}` : (this.lastFileName++).toString();\n      let fileName = baseFilename;\n      let i = 1; // Deal with `storiesOf()` being called twice in the same file.\n      // On HMR, `this.csfExports[fileName]` will be reset to `{}`, so an empty object is due\n      // to this export, not a second call of `storiesOf()`.\n\n      while (this.facade.csfExports[fileName] && Object.keys(this.facade.csfExports[fileName]).length > 0) {\n        i += 1;\n        fileName = `${baseFilename}-${i}`;\n      }\n\n      if (m && m.hot && m.hot.accept) {\n        // This module used storiesOf(), so when it re-runs on HMR, it will reload\n        // itself automatically without us needing to look at our imports\n        m.hot.accept();\n        m.hot.dispose(() => {\n          this.facade.clearFilenameExports(fileName); // We need to update the importFn as soon as the module re-evaluates\n          // (and calls storiesOf() again, etc). We could call `onImportFnChanged()`\n          // at the end of every setStories call (somehow), but then we'd need to\n          // debounce it somehow for initial startup. Instead, we'll take advantage of\n          // the fact that the evaluation of the module happens immediately in the same tick\n\n          setTimeout(() => {\n            this.onImportFnChanged?.({\n              importFn: this.importFn.bind(this)\n            });\n          }, 0);\n        });\n      }\n\n      let hasAdded = false;\n      const api = {\n        kind: kind.toString(),\n        add: () => api,\n        addDecorator: () => api,\n        addLoader: () => api,\n        addParameters: () => api\n      }; // apply addons\n\n      Object.keys(this.addons).forEach(name => {\n        const addon = this.addons[name];\n\n        api[name] = (...args) => {\n          addon.apply(api, args);\n          return api;\n        };\n      });\n      const meta = {\n        id: sanitize(kind),\n        title: kind,\n        decorators: [],\n        loaders: [],\n        parameters: {}\n      }; // We map these back to a simple default export, even though we have type guarantees at this point\n\n      this.facade.csfExports[fileName] = {\n        default: meta\n      };\n      let counter = 0;\n\n      api.add = (storyName, storyFn, parameters = {}) => {\n        hasAdded = true;\n\n        if (typeof storyName !== 'string') {\n          throw new Error(`Invalid or missing storyName provided for a \"${kind}\" story.`);\n        }\n\n        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn)) {\n          throw new Error(`Cannot load story \"${storyName}\" in \"${kind}\" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`);\n        }\n\n        const {\n          decorators,\n          loaders,\n          component,\n          args,\n          argTypes\n        } = parameters,\n              storyParameters = _objectWithoutPropertiesLoose(parameters, _excluded2); // eslint-disable-next-line no-underscore-dangle\n\n\n        const storyId = parameters.__id || toId(kind, storyName);\n        const csfExports = this.facade.csfExports[fileName]; // Whack a _ on the front incase it is \"default\"\n\n        csfExports[`story${counter}`] = {\n          name: storyName,\n          parameters: Object.assign({\n            fileName,\n            __id: storyId\n          }, storyParameters),\n          decorators,\n          loaders,\n          args,\n          argTypes,\n          component,\n          render: storyFn\n        };\n        counter += 1;\n        this.facade.entries[storyId] = {\n          id: storyId,\n          title: csfExports.default.title,\n          name: storyName,\n          importPath: fileName,\n          type: 'story'\n        };\n        return api;\n      };\n\n      api.addDecorator = decorator => {\n        if (hasAdded) throw new Error(`You cannot add a decorator after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.decorators.push(decorator);\n        return api;\n      };\n\n      api.addLoader = loader => {\n        if (hasAdded) throw new Error(`You cannot add a loader after the first story for a kind.`);\n        meta.loaders.push(loader);\n        return api;\n      };\n\n      api.addParameters = _ref2 => {\n        let {\n          component,\n          args,\n          argTypes\n        } = _ref2,\n            parameters = _objectWithoutPropertiesLoose(_ref2, _excluded3);\n\n        if (hasAdded) throw new Error(`You cannot add parameters after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.parameters = combineParameters(meta.parameters, parameters);\n        if (component) meta.component = component;\n        if (args) meta.args = Object.assign({}, meta.args, args);\n        if (argTypes) meta.argTypes = Object.assign({}, meta.argTypes, argTypes);\n        return api;\n      };\n\n      return api;\n    };\n\n    this.getStorybook = () => {\n      const {\n        entries\n      } = this.storyStore.storyIndex;\n      const kinds = {};\n      Object.entries(entries).forEach(([storyId, {\n        title,\n        name,\n        importPath,\n        type\n      }]) => {\n        if (type && type !== 'story') return;\n\n        if (!kinds[title]) {\n          kinds[title] = {\n            kind: title,\n            fileName: importPath,\n            stories: []\n          };\n        }\n\n        const {\n          storyFn\n        } = this.storyStore.fromId(storyId);\n        kinds[title].stories.push({\n          name,\n          render: storyFn\n        });\n      });\n      return Object.values(kinds);\n    };\n\n    this.raw = () => {\n      return this.storyStore.raw();\n    };\n\n    this.facade = new StoryStoreFacade();\n    this.addons = {};\n    this.storyStore = storyStore; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    singleton = this;\n  }\n\n  importFn(path) {\n    return this.facade.importFn(path);\n  }\n\n  getStoryIndex() {\n    if (!this.storyStore) {\n      throw new Error('Cannot get story index before setting storyStore');\n    }\n\n    return this.facade.getStoryIndex(this.storyStore);\n  }\n\n  // @deprecated\n  get _storyStore() {\n    return this.storyStore;\n  }\n\n}","import { dedent } from 'ts-dedent';\nimport memoize from 'memoizerific';\nconst getImportPathMap = memoize(1)(entries => Object.values(entries).reduce((acc, entry) => {\n  acc[entry.importPath] = acc[entry.importPath] || entry;\n  return acc;\n}, {}));\nexport class StoryIndexStore {\n  constructor({\n    entries\n  } = {\n    v: 4,\n    entries: {}\n  }) {\n    this.entries = void 0;\n    this.entries = entries;\n  }\n\n  entryFromSpecifier(specifier) {\n    const entries = Object.values(this.entries);\n\n    if (specifier === '*') {\n      // '*' means select the first entry. If there is none, we have no selection.\n      return entries[0];\n    }\n\n    if (typeof specifier === 'string') {\n      // Find the story with the exact id that matches the specifier (see #11571)\n      if (this.entries[specifier]) {\n        return this.entries[specifier];\n      } // Fallback to the first story that starts with the specifier\n\n\n      return entries.find(entry => entry.id.startsWith(specifier));\n    } // Try and find a story matching the name/kind, setting no selection if they don't exist.\n\n\n    const {\n      name,\n      title\n    } = specifier;\n    return entries.find(entry => entry.name === name && entry.title === title);\n  }\n\n  storyIdToEntry(storyId) {\n    const storyEntry = this.entries[storyId];\n\n    if (!storyEntry) {\n      throw new Error(dedent`Couldn't find story matching '${storyId}' after HMR.\n      - Did you remove it from your CSF file?\n      - Are you sure a story with that id exists?\n      - Please check your entries field of your main.js config.\n      - Also check the browser console and terminal for error messages.`);\n    }\n\n    return storyEntry;\n  }\n\n  importPathToEntry(importPath) {\n    return getImportPathMap(this.entries)[importPath];\n  }\n\n}","import { dequal as deepEqual } from 'dequal';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject';\nimport { dedent } from 'ts-dedent';\nconst INCOMPATIBLE = Symbol('incompatible');\n\nconst map = (arg, argType) => {\n  const type = argType.type;\n  if (arg === undefined || arg === null || !type) return arg;\n\n  if (argType.mapping) {\n    return arg;\n  }\n\n  switch (type.name) {\n    case 'string':\n      return String(arg);\n\n    case 'enum':\n      return arg;\n\n    case 'number':\n      return Number(arg);\n\n    case 'boolean':\n      return arg === 'true';\n\n    case 'array':\n      if (!type.value || !Array.isArray(arg)) return INCOMPATIBLE;\n      return arg.reduce((acc, item, index) => {\n        const mapped = map(item, {\n          type: type.value\n        });\n        if (mapped !== INCOMPATIBLE) acc[index] = mapped;\n        return acc;\n      }, new Array(arg.length));\n\n    case 'object':\n      if (typeof arg === 'string' || typeof arg === 'number') return arg;\n      if (!type.value || typeof arg !== 'object') return INCOMPATIBLE;\n      return Object.entries(arg).reduce((acc, [key, val]) => {\n        const mapped = map(val, {\n          type: type.value[key]\n        });\n        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n          [key]: mapped\n        });\n      }, {});\n\n    default:\n      return INCOMPATIBLE;\n  }\n};\n\nexport const mapArgsToTypes = (args, argTypes) => {\n  return Object.entries(args).reduce((acc, [key, value]) => {\n    if (!argTypes[key]) return acc;\n    const mapped = map(value, argTypes[key]);\n    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n      [key]: mapped\n    });\n  }, {});\n};\nexport const combineArgs = (value, update) => {\n  if (Array.isArray(value) && Array.isArray(update)) {\n    return update.reduce((acc, upd, index) => {\n      acc[index] = combineArgs(value[index], update[index]);\n      return acc;\n    }, [...value]).filter(v => v !== undefined);\n  }\n\n  if (!isPlainObject(value) || !isPlainObject(update)) return update;\n  return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n    if (key in update) {\n      const combined = combineArgs(value[key], update[key]);\n      if (combined !== undefined) acc[key] = combined;\n    } else {\n      acc[key] = value[key];\n    }\n\n    return acc;\n  }, {});\n};\nexport const validateOptions = (args, argTypes) => {\n  return Object.entries(argTypes).reduce((acc, [key, {\n    options\n  }]) => {\n    // Don't set args that are not defined in `args` (they can be undefined in there)\n    // see https://github.com/storybookjs/storybook/issues/15630 and\n    //   https://github.com/storybookjs/storybook/issues/17063\n    function allowArg() {\n      if (key in args) {\n        acc[key] = args[key];\n      }\n\n      return acc;\n    }\n\n    if (!options) return allowArg();\n\n    if (!Array.isArray(options)) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should be an array.\n\n        More info: https://storybook.js.org/docs/react/api/argtypes\n      `);\n      return allowArg();\n    }\n\n    if (options.some(opt => opt && ['object', 'function'].includes(typeof opt))) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.\n\n        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n      `);\n      return allowArg();\n    }\n\n    const isArray = Array.isArray(args[key]);\n    const invalidIndex = isArray && args[key].findIndex(val => !options.includes(val));\n    const isValidArray = isArray && invalidIndex === -1;\n\n    if (args[key] === undefined || options.includes(args[key]) || isValidArray) {\n      return allowArg();\n    }\n\n    const field = isArray ? `${key}[${invalidIndex}]` : key;\n    const supportedOptions = options.map(opt => typeof opt === 'string' ? `'${opt}'` : String(opt)).join(', ');\n    once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`);\n    return acc;\n  }, {});\n}; // TODO -- copied from router, needs to be in a shared location\n\nexport const DEEPLY_EQUAL = Symbol('Deeply equal');\nexport const deepDiff = (value, update) => {\n  if (typeof value !== typeof update) return update;\n  if (deepEqual(value, update)) return DEEPLY_EQUAL;\n\n  if (Array.isArray(value) && Array.isArray(update)) {\n    const res = update.reduce((acc, upd, index) => {\n      const diff = deepDiff(value[index], upd);\n      if (diff !== DEEPLY_EQUAL) acc[index] = diff;\n      return acc;\n    }, new Array(update.length));\n    if (update.length >= value.length) return res;\n    return res.concat(new Array(value.length - update.length).fill(undefined));\n  }\n\n  if (isPlainObject(value) && isPlainObject(update)) {\n    return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n      const diff = deepDiff(value?.[key], update?.[key]);\n      return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, {\n        [key]: diff\n      });\n    }, {});\n  }\n\n  return update;\n};\nexport const NO_TARGET_NAME = '';\nexport function groupArgsByTarget({\n  args,\n  argTypes\n}) {\n  const groupedArgs = {};\n  Object.entries(args).forEach(([name, value]) => {\n    const {\n      target = NO_TARGET_NAME\n    } = argTypes[name] || {};\n    groupedArgs[target] = groupedArgs[target] || {};\n    groupedArgs[target][name] = value;\n  });\n  return groupedArgs;\n}\nexport function noTargetArgs(context) {\n  return groupArgsByTarget(context)[NO_TARGET_NAME];\n}","import deprecate from 'util-deprecate';\nimport { dedent } from 'ts-dedent';\nimport { deepDiff, DEEPLY_EQUAL } from './args';\nimport { getValuesFromArgTypes } from './csf/getValuesFromArgTypes';\nconst setUndeclaredWarning = deprecate(() => {}, dedent`\n    Setting a global value that is undeclared (i.e. not in the user's initial set of globals\n    or globalTypes) is deprecated and will have no effect in 7.0.\n  `);\nexport class GlobalsStore {\n  // We use ! here because TS doesn't analyse the .set() function to see if it actually get set\n  constructor({\n    globals = {},\n    globalTypes = {}\n  }) {\n    this.allowedGlobalNames = void 0;\n    this.initialGlobals = void 0;\n    this.globals = void 0;\n    this.set({\n      globals,\n      globalTypes\n    });\n  }\n\n  set({\n    globals = {},\n    globalTypes = {}\n  }) {\n    const delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);\n    this.allowedGlobalNames = new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);\n    const defaultGlobals = getValuesFromArgTypes(globalTypes);\n    this.initialGlobals = Object.assign({}, defaultGlobals, globals);\n    this.globals = this.initialGlobals;\n\n    if (delta && delta !== DEEPLY_EQUAL) {\n      this.updateFromPersisted(delta);\n    }\n  }\n\n  filterAllowedGlobals(globals) {\n    return Object.entries(globals).reduce((acc, [key, value]) => {\n      if (this.allowedGlobalNames.has(key)) acc[key] = value;\n      return acc;\n    }, {});\n  }\n\n  updateFromPersisted(persisted) {\n    const allowedUrlGlobals = this.filterAllowedGlobals(persisted); // Note that unlike args, we do not have the same type information for globals to allow us\n    // to type check them here, so we just set them naively\n\n    this.globals = Object.assign({}, this.globals, allowedUrlGlobals);\n  }\n\n  get() {\n    return this.globals;\n  }\n\n  update(newGlobals) {\n    Object.keys(newGlobals).forEach(key => {\n      if (!this.allowedGlobalNames.has(key)) {\n        setUndeclaredWarning();\n      }\n    });\n    this.globals = Object.assign({}, this.globals, newGlobals);\n  }\n\n}","import { storyNameFromExport, toId } from '@storybook/csf';\nimport { dedent } from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport deprecate from 'util-deprecate';\nimport { normalizeInputTypes } from './normalizeInputTypes';\nconst deprecatedStoryAnnotation = dedent`\nCSF .story annotations deprecated; annotate story functions directly:\n- StoryFn.story.name => StoryFn.storyName\n- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)\nSee https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.\n`;\nconst deprecatedStoryAnnotationWarning = deprecate(() => {}, deprecatedStoryAnnotation);\nexport function normalizeStory(key, storyAnnotations, meta) {\n  const storyObject = storyAnnotations;\n  const userStoryFn = typeof storyAnnotations === 'function' ? storyAnnotations : null;\n  const {\n    story\n  } = storyObject;\n\n  if (story) {\n    logger.debug('deprecated story', story);\n    deprecatedStoryAnnotationWarning();\n  }\n\n  const exportName = storyNameFromExport(key);\n  const name = typeof storyObject !== 'function' && storyObject.name || storyObject.storyName || story?.name || exportName;\n  const decorators = [...(storyObject.decorators || []), ...(story?.decorators || [])];\n  const parameters = Object.assign({}, story?.parameters, storyObject.parameters);\n  const args = Object.assign({}, story?.args, storyObject.args);\n  const argTypes = Object.assign({}, story?.argTypes, storyObject.argTypes);\n  const loaders = [...(storyObject.loaders || []), ...(story?.loaders || [])];\n  const {\n    render,\n    play\n  } = storyObject; // eslint-disable-next-line no-underscore-dangle\n\n  const id = parameters.__id || toId(meta.id, exportName);\n  return Object.assign({\n    moduleExport: storyAnnotations,\n    id,\n    name,\n    decorators,\n    parameters,\n    args,\n    argTypes: normalizeInputTypes(argTypes),\n    loaders\n  }, render && {\n    render\n  }, userStoryFn && {\n    userStoryFn\n  }, play && {\n    play\n  });\n}","import { dedent } from 'ts-dedent';\nimport deprecate from 'util-deprecate';\nimport global from 'global';\nimport { includeConditionalArg } from '@storybook/csf';\nimport { combineParameters } from '../parameters';\nimport { applyHooks } from '../hooks';\nimport { defaultDecorateStory } from '../decorators';\nimport { groupArgsByTarget, NO_TARGET_NAME } from '../args';\nimport { getValuesFromArgTypes } from './getValuesFromArgTypes';\nconst argTypeDefaultValueWarning = deprecate(() => {}, dedent`\n  \\`argType.defaultValue\\` is deprecated and will be removed in Storybook 7.0.\n\n  https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#no-longer-inferring-default-values-of-args`); // Combine all the metadata about a story (both direct and inherited from the component/global scope)\n// into a \"renderable\" story function, with all decorators applied, parameters passed as context etc\n//\n// Note that this story function is *stateless* in the sense that it does not track args or globals\n// Instead, it is expected these are tracked separately (if necessary) and are passed into each invocation.\n\nexport function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {\n  // NOTE: in the current implementation we are doing everything once, up front, rather than doing\n  // anything at render time. The assumption is that as we don't load all the stories at once, this\n  // will have a limited cost. If this proves misguided, we can refactor it.\n  const {\n    moduleExport,\n    id,\n    name\n  } = storyAnnotations;\n  const {\n    title\n  } = componentAnnotations;\n  const parameters = combineParameters(projectAnnotations.parameters, componentAnnotations.parameters, storyAnnotations.parameters);\n  const decorators = [...(storyAnnotations.decorators || []), ...(componentAnnotations.decorators || []), ...(projectAnnotations.decorators || [])]; // Currently it is only possible to set these globally\n\n  const {\n    applyDecorators = defaultDecorateStory,\n    argTypesEnhancers = [],\n    argsEnhancers = []\n  } = projectAnnotations;\n  const loaders = [...(projectAnnotations.loaders || []), ...(componentAnnotations.loaders || []), ...(storyAnnotations.loaders || [])]; // The render function on annotations *has* to be an `ArgsStoryFn`, so when we normalize\n  // CSFv1/2, we use a new field called `userStoryFn` so we know that it can be a LegacyStoryFn\n\n  const render = storyAnnotations.userStoryFn || storyAnnotations.render || componentAnnotations.render || projectAnnotations.render;\n  if (!render) throw new Error(`No render function available for storyId '${id}'`);\n  const passedArgTypes = combineParameters(projectAnnotations.argTypes, componentAnnotations.argTypes, storyAnnotations.argTypes);\n  const {\n    passArgsFirst = true\n  } = parameters; // eslint-disable-next-line no-underscore-dangle\n\n  parameters.__isArgsStory = passArgsFirst && render.length > 0; // Pull out args[X] into initialArgs for argTypes enhancers\n\n  const passedArgs = Object.assign({}, projectAnnotations.args, componentAnnotations.args, storyAnnotations.args);\n  const contextForEnhancers = {\n    componentId: componentAnnotations.id,\n    title,\n    kind: title,\n    // Back compat\n    id,\n    name,\n    story: name,\n    // Back compat\n    component: componentAnnotations.component,\n    subcomponents: componentAnnotations.subcomponents,\n    parameters,\n    initialArgs: passedArgs,\n    argTypes: passedArgTypes\n  };\n  contextForEnhancers.argTypes = argTypesEnhancers.reduce((accumulatedArgTypes, enhancer) => enhancer(Object.assign({}, contextForEnhancers, {\n    argTypes: accumulatedArgTypes\n  })), contextForEnhancers.argTypes); // Add argTypes[X].defaultValue to initial args (note this deprecated)\n  // We need to do this *after* the argTypesEnhancers as they may add defaultValues\n\n  const defaultArgs = getValuesFromArgTypes(contextForEnhancers.argTypes);\n\n  if (Object.keys(defaultArgs).length > 0) {\n    argTypeDefaultValueWarning();\n  }\n\n  const initialArgsBeforeEnhancers = Object.assign({}, defaultArgs, passedArgs);\n  contextForEnhancers.initialArgs = argsEnhancers.reduce((accumulatedArgs, enhancer) => Object.assign({}, accumulatedArgs, enhancer(Object.assign({}, contextForEnhancers, {\n    initialArgs: accumulatedArgs\n  }))), initialArgsBeforeEnhancers); // Add some of our metadata into parameters as we used to do this in 6.x and users may be relying on it\n\n  if (!global.FEATURES?.breakingChangesV7) {\n    contextForEnhancers.parameters = Object.assign({}, contextForEnhancers.parameters, {\n      __id: id,\n      globals: projectAnnotations.globals,\n      globalTypes: projectAnnotations.globalTypes,\n      args: contextForEnhancers.initialArgs,\n      argTypes: contextForEnhancers.argTypes\n    });\n  }\n\n  const applyLoaders = async context => {\n    const loadResults = await Promise.all(loaders.map(loader => loader(context)));\n    const loaded = Object.assign({}, ...loadResults);\n    return Object.assign({}, context, {\n      loaded\n    });\n  };\n\n  const undecoratedStoryFn = context => {\n    const mappedArgs = Object.entries(context.args).reduce((acc, [key, val]) => {\n      const mapping = context.argTypes[key]?.mapping;\n      acc[key] = mapping && val in mapping ? mapping[val] : val;\n      return acc;\n    }, {});\n    const includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {\n      const argType = context.argTypes[key] || {};\n      if (includeConditionalArg(argType, mappedArgs, context.globals)) acc[key] = val;\n      return acc;\n    }, {});\n    const includedContext = Object.assign({}, context, {\n      args: includedArgs\n    });\n    const {\n      passArgsFirst: renderTimePassArgsFirst = true\n    } = context.parameters;\n    return renderTimePassArgsFirst ? render(includedContext.args, includedContext) : render(includedContext);\n  };\n\n  const decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators);\n\n  const unboundStoryFn = context => {\n    let finalContext = context;\n\n    if (global.FEATURES?.argTypeTargetsV7) {\n      const argsByTarget = groupArgsByTarget(context);\n      finalContext = Object.assign({}, context, {\n        allArgs: context.args,\n        argsByTarget,\n        args: argsByTarget[NO_TARGET_NAME] || {}\n      });\n    }\n\n    return decoratedStoryFn(finalContext);\n  };\n\n  const playFunction = storyAnnotations.play;\n  return Object.freeze(Object.assign({}, contextForEnhancers, {\n    moduleExport,\n    originalStoryFn: render,\n    undecoratedStoryFn,\n    unboundStoryFn,\n    applyLoaders,\n    playFunction\n  }));\n}","import mapValues from 'lodash/mapValues';\nimport { dedent } from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport { combineParameters } from './parameters';\n\nconst inferType = (value, name, visited) => {\n  const type = typeof value;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'function':\n    case 'symbol':\n      return {\n        name: type\n      };\n\n    default:\n      break;\n  }\n\n  if (value) {\n    if (visited.has(value)) {\n      logger.warn(dedent`\n        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.\n\n        Consider using the mapping feature or fully custom args:\n        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args\n      `);\n      return {\n        name: 'other',\n        value: 'cyclic object'\n      };\n    }\n\n    visited.add(value);\n\n    if (Array.isArray(value)) {\n      const childType = value.length > 0 ? inferType(value[0], name, new Set(visited)) : {\n        name: 'other',\n        value: 'unknown'\n      };\n      return {\n        name: 'array',\n        value: childType\n      };\n    }\n\n    const fieldTypes = mapValues(value, field => inferType(field, name, new Set(visited)));\n    return {\n      name: 'object',\n      value: fieldTypes\n    };\n  }\n\n  return {\n    name: 'object',\n    value: {}\n  };\n};\n\nexport const inferArgTypes = context => {\n  const {\n    id,\n    argTypes: userArgTypes = {},\n    initialArgs = {}\n  } = context;\n  const argTypes = mapValues(initialArgs, (arg, key) => ({\n    name: key,\n    type: inferType(arg, `${id}.${key}`, new Set())\n  }));\n  const userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({\n    name: key\n  }));\n  return combineParameters(argTypes, userArgTypesNames, userArgTypes);\n};\ninferArgTypes.secondPass = true;","import { dedent } from 'ts-dedent';\nimport global from 'global';\nimport { SynchronousPromise } from 'synchronous-promise';\nimport { CONFIG_ERROR, FORCE_REMOUNT, FORCE_RE_RENDER, GLOBALS_UPDATED, RESET_STORY_ARGS, SET_GLOBALS, STORY_ARGS_UPDATED, STORY_INDEX_INVALIDATED, UPDATE_GLOBALS, UPDATE_STORY_ARGS } from '@storybook/core-events';\nimport { logger } from '@storybook/client-logger';\nimport { addons } from '@storybook/addons';\nimport { StoryStore } from '@storybook/store';\nimport { StoryRender } from './render/StoryRender';\nconst {\n  fetch\n} = global;\nconst STORY_INDEX_PATH = './index.json';\nexport class Preview {\n  constructor() {\n    this.channel = void 0;\n    this.serverChannel = void 0;\n    this.storyStore = void 0;\n    this.getStoryIndex = void 0;\n    this.importFn = void 0;\n    this.renderToDOM = void 0;\n    this.storyRenders = [];\n    this.previewEntryError = void 0;\n    this.channel = addons.getChannel();\n\n    if (global.FEATURES?.storyStoreV7 && addons.hasServerChannel()) {\n      this.serverChannel = addons.getServerChannel();\n    }\n\n    this.storyStore = new StoryStore();\n  } // INITIALIZATION\n  // NOTE: the reason that the preview and store's initialization code is written in a promise\n  // style and not `async-await`, and the use of `SynchronousPromise`s is in order to allow\n  // storyshots to immediately call `raw()` on the store without waiting for a later tick.\n  // (Even simple things like `Promise.resolve()` and `await` involve the callback happening\n  // in the next promise \"tick\").\n  // See the comment in `storyshots-core/src/api/index.ts` for more detail.\n\n\n  initialize({\n    getStoryIndex,\n    importFn,\n    getProjectAnnotations\n  }) {\n    // We save these two on initialization in case `getProjectAnnotations` errors,\n    // in which case we may need them later when we recover.\n    this.getStoryIndex = getStoryIndex;\n    this.importFn = importFn;\n    this.setupListeners();\n    return this.getProjectAnnotationsOrRenderError(getProjectAnnotations).then(projectAnnotations => this.initializeWithProjectAnnotations(projectAnnotations));\n  }\n\n  setupListeners() {\n    this.serverChannel?.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this));\n    this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));\n    this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));\n    this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this));\n    this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this));\n    this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this));\n  }\n\n  getProjectAnnotationsOrRenderError(getProjectAnnotations) {\n    return SynchronousPromise.resolve().then(getProjectAnnotations).then(projectAnnotations => {\n      this.renderToDOM = projectAnnotations.renderToDOM;\n\n      if (!this.renderToDOM) {\n        throw new Error(dedent`\n            Expected your framework's preset to export a \\`renderToDOM\\` field.\n\n            Perhaps it needs to be upgraded for Storybook 6.4?\n\n            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field          \n          `);\n      }\n\n      return projectAnnotations;\n    }).catch(err => {\n      // This is an error extracting the projectAnnotations (i.e. evaluating the previewEntries) and\n      // needs to be show to the user as a simple error\n      this.renderPreviewEntryError('Error reading preview.js:', err);\n      throw err;\n    });\n  } // If initialization gets as far as project annotations, this function runs.\n\n\n  initializeWithProjectAnnotations(projectAnnotations) {\n    this.storyStore.setProjectAnnotations(projectAnnotations);\n    this.setInitialGlobals();\n    let storyIndexPromise;\n\n    if (global.FEATURES?.storyStoreV7) {\n      storyIndexPromise = this.getStoryIndexFromServer();\n    } else {\n      if (!this.getStoryIndex) {\n        throw new Error('No `getStoryIndex` passed defined in v6 mode');\n      }\n\n      storyIndexPromise = SynchronousPromise.resolve().then(this.getStoryIndex);\n    }\n\n    return storyIndexPromise.then(storyIndex => this.initializeWithStoryIndex(storyIndex)).catch(err => {\n      this.renderPreviewEntryError('Error loading story index:', err);\n      throw err;\n    });\n  }\n\n  async setInitialGlobals() {\n    this.emitGlobals();\n  }\n\n  emitGlobals() {\n    if (!this.storyStore.globals || !this.storyStore.projectAnnotations) throw new Error(`Cannot emit before initialization`);\n    this.channel.emit(SET_GLOBALS, {\n      globals: this.storyStore.globals.get() || {},\n      globalTypes: this.storyStore.projectAnnotations.globalTypes || {}\n    });\n  }\n\n  async getStoryIndexFromServer() {\n    const result = await fetch(STORY_INDEX_PATH);\n    if (result.status === 200) return result.json();\n    throw new Error(await result.text());\n  } // If initialization gets as far as the story index, this function runs.\n\n\n  initializeWithStoryIndex(storyIndex) {\n    if (!this.importFn) throw new Error(`Cannot call initializeWithStoryIndex before initialization`);\n    return this.storyStore.initialize({\n      storyIndex,\n      importFn: this.importFn,\n      cache: !global.FEATURES?.storyStoreV7\n    });\n  } // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n\n\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    delete this.previewEntryError;\n    const projectAnnotations = await this.getProjectAnnotationsOrRenderError(getProjectAnnotations);\n\n    if (!this.storyStore.projectAnnotations) {\n      await this.initializeWithProjectAnnotations(projectAnnotations);\n      return;\n    }\n\n    await this.storyStore.setProjectAnnotations(projectAnnotations);\n    this.emitGlobals();\n  }\n\n  async onStoryIndexChanged() {\n    delete this.previewEntryError;\n\n    if (!this.storyStore.projectAnnotations) {\n      // We haven't successfully set project annotations yet,\n      // we need to do that before we can do anything else.\n      return;\n    }\n\n    try {\n      const storyIndex = await this.getStoryIndexFromServer(); // This is the first time the story index worked, let's load it into the store\n\n      if (!this.storyStore.storyIndex) {\n        await this.initializeWithStoryIndex(storyIndex);\n      } // Update the store with the new stories.\n\n\n      await this.onStoriesChanged({\n        storyIndex\n      });\n    } catch (err) {\n      this.renderPreviewEntryError('Error loading story index:', err);\n      throw err;\n    }\n  } // This happens when a glob gets HMR-ed\n\n\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    await this.storyStore.onStoriesChanged({\n      importFn,\n      storyIndex\n    });\n  }\n\n  async onUpdateGlobals({\n    globals\n  }) {\n    if (!this.storyStore.globals) throw new Error(`Cannot call onUpdateGlobals before initialization`);\n    this.storyStore.globals.update(globals);\n    await Promise.all(this.storyRenders.map(r => r.rerender()));\n    this.channel.emit(GLOBALS_UPDATED, {\n      globals: this.storyStore.globals.get(),\n      initialGlobals: this.storyStore.globals.initialGlobals\n    });\n  }\n\n  async onUpdateArgs({\n    storyId,\n    updatedArgs\n  }) {\n    this.storyStore.args.update(storyId, updatedArgs);\n    await Promise.all(this.storyRenders.filter(r => r.id === storyId).map(r => r.rerender()));\n    this.channel.emit(STORY_ARGS_UPDATED, {\n      storyId,\n      args: this.storyStore.args.get(storyId)\n    });\n  }\n\n  async onResetArgs({\n    storyId,\n    argNames\n  }) {\n    // NOTE: we have to be careful here and avoid await-ing when updating a rendered's args.\n    // That's because below in `renderStoryToElement` we have also bound to this event and will\n    // render the story in the same tick.\n    // However, we can do that safely as the current story is available in `this.storyRenders`\n    const render = this.storyRenders.find(r => r.id === storyId);\n    const story = render?.story || (await this.storyStore.loadStory({\n      storyId\n    }));\n    const argNamesToReset = argNames || [...new Set([...Object.keys(story.initialArgs), ...Object.keys(this.storyStore.args.get(storyId))])];\n    const updatedArgs = argNamesToReset.reduce((acc, argName) => {\n      acc[argName] = story.initialArgs[argName];\n      return acc;\n    }, {});\n    await this.onUpdateArgs({\n      storyId,\n      updatedArgs\n    });\n  } // ForceReRender does not include a story id, so we simply must\n  // re-render all stories in case they are relevant\n\n\n  async onForceReRender() {\n    await Promise.all(this.storyRenders.map(r => r.rerender()));\n  }\n\n  async onForceRemount({\n    storyId\n  }) {\n    await Promise.all(this.storyRenders.filter(r => r.id === storyId).map(r => r.remount()));\n  } // Used by docs' modernInlineRender to render a story to a given element\n  // Note this short-circuits the `prepare()` phase of the StoryRender,\n  // main to be consistent with the previous behaviour. In the future,\n  // we will change it to go ahead and load the story, which will end up being\n  // \"instant\", although async.\n\n\n  renderStoryToElement(story, element) {\n    if (!this.renderToDOM) throw new Error(`Cannot call renderStoryToElement before initialization`);\n    const render = new StoryRender(this.channel, this.storyStore, this.renderToDOM, this.inlineStoryCallbacks(story.id), story.id, 'docs', story);\n    render.renderToElement(element);\n    this.storyRenders.push(render);\n    return async () => {\n      await this.teardownRender(render);\n    };\n  }\n\n  async teardownRender(render, {\n    viewModeChanged\n  } = {}) {\n    this.storyRenders = this.storyRenders.filter(r => r !== render);\n    await render?.teardown?.({\n      viewModeChanged\n    });\n  } // API\n\n\n  async extract(options) {\n    if (this.previewEntryError) {\n      throw this.previewEntryError;\n    }\n\n    if (!this.storyStore.projectAnnotations) {\n      // In v6 mode, if your preview.js throws, we never get a chance to initialize the preview\n      // or store, and the error is simply logged to the browser console. This is the best we can do\n      throw new Error(dedent`Failed to initialize Storybook.\n      \n      Do you have an error in your \\`preview.js\\`? Check your Storybook's browser console for errors.`);\n    }\n\n    if (global.FEATURES?.storyStoreV7) {\n      await this.storyStore.cacheAllCSFFiles();\n    }\n\n    return this.storyStore.extract(options);\n  } // UTILITIES\n\n\n  inlineStoryCallbacks(storyId) {\n    return {\n      showMain: () => {},\n      showError: err => logger.error(`Error rendering docs story (${storyId})`, err),\n      showException: err => logger.error(`Error rendering docs story (${storyId})`, err)\n    };\n  }\n\n  renderPreviewEntryError(reason, err) {\n    this.previewEntryError = err;\n    logger.error(reason);\n    logger.error(err);\n    this.channel.emit(CONFIG_ERROR, err);\n  }\n\n}","import qs from 'qs';\nimport { dedent } from 'ts-dedent';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject'; // Keep this in sync with validateArgs in router/src/utils.ts\n\nconst VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;\nconst NUMBER_REGEXP = /^-?[0-9]+(\\.[0-9]+)?$/;\nconst HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;\nconst COLOR_REGEXP = /^(rgba?|hsla?)\\(([0-9]{1,3}),\\s?([0-9]{1,3})%?,\\s?([0-9]{1,3})%?,?\\s?([0-9](\\.[0-9]{1,2})?)?\\)$/i;\n\nconst validateArgs = (key = '', value) => {\n  if (key === null) return false;\n  if (key === '' || !VALIDATION_REGEXP.test(key)) return false;\n  if (value === null || value === undefined) return true; // encoded as `!null` or `!undefined`\n\n  if (value instanceof Date) return true; // encoded as modified ISO string\n\n  if (typeof value === 'number' || typeof value === 'boolean') return true;\n\n  if (typeof value === 'string') {\n    return VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value);\n  }\n\n  if (Array.isArray(value)) return value.every(v => validateArgs(key, v));\n  if (isPlainObject(value)) return Object.entries(value).every(([k, v]) => validateArgs(k, v));\n  return false;\n};\n\nconst QS_OPTIONS = {\n  delimiter: ';',\n  // we're parsing a single query param\n  allowDots: true,\n  // objects are encoded using dot notation\n  allowSparse: true,\n\n  // arrays will be merged on top of their initial value\n  decoder(str, defaultDecoder, charset, type) {\n    if (type === 'value' && str.startsWith('!')) {\n      if (str === '!undefined') return undefined;\n      if (str === '!null') return null;\n      if (str.startsWith('!date(') && str.endsWith(')')) return new Date(str.slice(6, -1));\n      if (str.startsWith('!hex(') && str.endsWith(')')) return `#${str.slice(5, -1)}`;\n      const color = str.slice(1).match(COLOR_REGEXP);\n\n      if (color) {\n        if (str.startsWith('!rgba')) return `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})`;\n        if (str.startsWith('!hsla')) return `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})`;\n        return str.startsWith('!rgb') ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;\n      }\n    }\n\n    if (type === 'value' && NUMBER_REGEXP.test(str)) return Number(str);\n    return defaultDecoder(str, defaultDecoder, charset);\n  }\n\n};\nexport const parseArgsParam = argsString => {\n  const parts = argsString.split(';').map(part => part.replace('=', '~').replace(':', '='));\n  return Object.entries(qs.parse(parts.join(';'), QS_OPTIONS)).reduce((acc, [key, value]) => {\n    if (validateArgs(key, value)) return Object.assign(acc, {\n      [key]: value\n    });\n    once.warn(dedent`\n      Omitted potentially unsafe URL args.\n\n      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url\n    `);\n    return acc;\n  }, {});\n};","import global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport AnsiToHtml from 'ansi-to-html';\nimport { dedent } from 'ts-dedent';\nimport qs from 'qs';\nconst {\n  document\n} = global;\nconst PREPARING_DELAY = 100;\nconst layoutClassMap = {\n  centered: 'sb-main-centered',\n  fullscreen: 'sb-main-fullscreen',\n  padded: 'sb-main-padded'\n};\nvar Mode;\n\n(function (Mode) {\n  Mode[\"MAIN\"] = \"MAIN\";\n  Mode[\"NOPREVIEW\"] = \"NOPREVIEW\";\n  Mode[\"PREPARING_STORY\"] = \"PREPARING_STORY\";\n  Mode[\"PREPARING_DOCS\"] = \"PREPARING_DOCS\";\n  Mode[\"ERROR\"] = \"ERROR\";\n})(Mode || (Mode = {}));\n\nconst classes = {\n  PREPARING_STORY: 'sb-show-preparing-story',\n  PREPARING_DOCS: 'sb-show-preparing-docs',\n  MAIN: 'sb-show-main',\n  NOPREVIEW: 'sb-show-nopreview',\n  ERROR: 'sb-show-errordisplay'\n};\nconst ansiConverter = new AnsiToHtml({\n  escapeXML: true\n});\nexport class WebView {\n  constructor() {\n    this.currentLayoutClass = void 0;\n    this.testing = false;\n    this.preparingTimeout = void 0;\n    // Special code for testing situations\n    const {\n      __SPECIAL_TEST_PARAMETER__\n    } = qs.parse(document.location.search, {\n      ignoreQueryPrefix: true\n    });\n\n    switch (__SPECIAL_TEST_PARAMETER__) {\n      case 'preparing-story':\n        {\n          this.showPreparingStory();\n          this.testing = true;\n          break;\n        }\n\n      case 'preparing-docs':\n        {\n          this.showPreparingDocs();\n          this.testing = true;\n          break;\n        }\n\n      default: // pass;\n\n    }\n  } // Get ready to render a story, returning the element to render to\n\n\n  prepareForStory(story) {\n    this.showStory();\n    this.applyLayout(story.parameters.layout);\n    document.documentElement.scrollTop = 0;\n    document.documentElement.scrollLeft = 0;\n    return this.storyRoot();\n  }\n\n  storyRoot() {\n    return document.getElementById('root');\n  }\n\n  prepareForDocs() {\n    this.showMain();\n    this.showDocs();\n    this.applyLayout('fullscreen');\n    return this.docsRoot();\n  }\n\n  docsRoot() {\n    return document.getElementById('docs-root');\n  }\n\n  applyLayout(layout = 'padded') {\n    if (layout === 'none') {\n      document.body.classList.remove(this.currentLayoutClass);\n      this.currentLayoutClass = null;\n      return;\n    }\n\n    this.checkIfLayoutExists(layout);\n    const layoutClass = layoutClassMap[layout];\n    document.body.classList.remove(this.currentLayoutClass);\n    document.body.classList.add(layoutClass);\n    this.currentLayoutClass = layoutClass;\n  }\n\n  checkIfLayoutExists(layout) {\n    if (!layoutClassMap[layout]) {\n      logger.warn(dedent`The desired layout: ${layout} is not a valid option.\n         The possible options are: ${Object.keys(layoutClassMap).join(', ')}, none.`);\n    }\n  }\n\n  showMode(mode) {\n    clearTimeout(this.preparingTimeout);\n    Object.keys(Mode).forEach(otherMode => {\n      if (otherMode === mode) {\n        document.body.classList.add(classes[otherMode]);\n      } else {\n        document.body.classList.remove(classes[otherMode]);\n      }\n    });\n  }\n\n  showErrorDisplay({\n    message = '',\n    stack = ''\n  }) {\n    let header = message;\n    let detail = stack;\n    const parts = message.split('\\n');\n\n    if (parts.length > 1) {\n      [header] = parts;\n      detail = parts.slice(1).join('\\n');\n    }\n\n    document.getElementById('error-message').innerHTML = ansiConverter.toHtml(header);\n    document.getElementById('error-stack').innerHTML = ansiConverter.toHtml(detail);\n    this.showMode(Mode.ERROR);\n  }\n\n  showNoPreview() {\n    if (this.testing) return;\n    this.showMode(Mode.NOPREVIEW); // In storyshots this can get called and these two can be null\n\n    this.storyRoot()?.setAttribute('hidden', 'true');\n    this.docsRoot()?.setAttribute('hidden', 'true');\n  }\n\n  showPreparingStory({\n    immediate = false\n  } = {}) {\n    clearTimeout(this.preparingTimeout);\n\n    if (immediate) {\n      this.showMode(Mode.PREPARING_STORY);\n    } else {\n      this.preparingTimeout = setTimeout(() => this.showMode(Mode.PREPARING_STORY), PREPARING_DELAY);\n    }\n  }\n\n  showPreparingDocs() {\n    clearTimeout(this.preparingTimeout);\n    this.preparingTimeout = setTimeout(() => this.showMode(Mode.PREPARING_DOCS), PREPARING_DELAY);\n  }\n\n  showMain() {\n    this.showMode(Mode.MAIN);\n  }\n\n  showDocs() {\n    this.storyRoot().setAttribute('hidden', 'true');\n    this.docsRoot().removeAttribute('hidden');\n  }\n\n  showStory() {\n    this.docsRoot().setAttribute('hidden', 'true');\n    this.storyRoot().removeAttribute('hidden');\n  }\n\n  showStoryDuringRender() {\n    // When 'showStory' is called (at the start of rendering) we get rid of our display:none\n    // from all children of the root (but keep the preparing spinner visible). This may mean\n    // that very weird and high z-index stories are briefly visible.\n    // See https://github.com/storybookjs/storybook/issues/16847 and\n    //   http://localhost:9011/?path=/story/core-rendering--auto-focus (official SB)\n    document.body.classList.add(classes.MAIN);\n  }\n\n}","import deprecate from 'util-deprecate';\nimport { dedent } from 'ts-dedent';\nimport global from 'global';\nimport { CURRENT_STORY_WAS_SET, IGNORED_EXCEPTION, PRELOAD_STORIES, PREVIEW_KEYDOWN, SET_CURRENT_STORY, SET_STORIES, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_MISSING, STORY_PREPARED, STORY_RENDER_PHASE_CHANGED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, UPDATE_QUERY_PARAMS } from '@storybook/core-events';\nimport { logger } from '@storybook/client-logger';\nimport { Preview } from './Preview';\nimport { UrlStore } from './UrlStore';\nimport { WebView } from './WebView';\nimport { PREPARE_ABORTED, StoryRender } from './render/StoryRender';\nimport { TemplateDocsRender } from './render/TemplateDocsRender';\nimport { StandaloneDocsRender } from './render/StandaloneDocsRender';\nconst {\n  window: globalWindow\n} = global;\n\nfunction focusInInput(event) {\n  const target = event.target;\n  return /input|textarea/i.test(target.tagName) || target.getAttribute('contenteditable') !== null;\n}\n\nfunction isStoryRender(r) {\n  return r.type === 'story';\n}\n\nexport class PreviewWeb extends Preview {\n  constructor() {\n    super();\n    this.urlStore = void 0;\n    this.view = void 0;\n    this.previewEntryError = void 0;\n    this.currentSelection = void 0;\n    this.currentRender = void 0;\n    this.view = new WebView();\n    this.urlStore = new UrlStore(); // Add deprecated APIs for back-compat\n    // @ts-ignore\n\n    this.storyStore.getSelection = deprecate(() => this.urlStore.selection, dedent`\n        \\`__STORYBOOK_STORY_STORE__.getSelection()\\` is deprecated and will be removed in 7.0.\n\n        To get the current selection, use the \\`useStoryContext()\\` hook from \\`@storybook/addons\\`.\n      `);\n  }\n\n  setupListeners() {\n    super.setupListeners();\n    globalWindow.onkeydown = this.onKeydown.bind(this);\n    this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));\n    this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this));\n    this.channel.on(PRELOAD_STORIES, this.onPreloadStories.bind(this));\n  }\n\n  initializeWithProjectAnnotations(projectAnnotations) {\n    return super.initializeWithProjectAnnotations(projectAnnotations).then(() => this.setInitialGlobals());\n  }\n\n  async setInitialGlobals() {\n    if (!this.storyStore.globals) throw new Error(`Cannot call setInitialGlobals before initialization`);\n    const {\n      globals\n    } = this.urlStore.selectionSpecifier || {};\n\n    if (globals) {\n      this.storyStore.globals.updateFromPersisted(globals);\n    }\n\n    this.emitGlobals();\n  } // If initialization gets as far as the story index, this function runs.\n\n\n  initializeWithStoryIndex(storyIndex) {\n    return super.initializeWithStoryIndex(storyIndex).then(() => {\n      if (!global.FEATURES?.storyStoreV7) {\n        this.channel.emit(SET_STORIES, this.storyStore.getSetStoriesPayload());\n      }\n\n      return this.selectSpecifiedStory();\n    });\n  } // Use the selection specifier to choose a story, then render it\n\n\n  async selectSpecifiedStory() {\n    if (!this.storyStore.storyIndex) throw new Error(`Cannot call selectSpecifiedStory before initialization`);\n\n    if (!this.urlStore.selectionSpecifier) {\n      this.renderMissingStory();\n      return;\n    }\n\n    const {\n      storySpecifier,\n      args\n    } = this.urlStore.selectionSpecifier;\n    const entry = this.storyStore.storyIndex.entryFromSpecifier(storySpecifier);\n\n    if (!entry) {\n      if (storySpecifier === '*') {\n        this.renderStoryLoadingException(storySpecifier, new Error(dedent`\n            Couldn't find any stories in your Storybook.\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          `));\n      } else {\n        this.renderStoryLoadingException(storySpecifier, new Error(dedent`\n            Couldn't find story matching '${storySpecifier}'.\n            - Are you sure a story with that id exists?\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          `));\n      }\n\n      return;\n    }\n\n    const {\n      id: storyId,\n      type: viewMode\n    } = entry;\n    this.urlStore.setSelection({\n      storyId,\n      viewMode\n    });\n    this.channel.emit(STORY_SPECIFIED, this.urlStore.selection);\n    this.channel.emit(CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    await this.renderSelection({\n      persistedArgs: args\n    });\n  } // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n\n\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    await super.onGetProjectAnnotationsChanged({\n      getProjectAnnotations\n    });\n    this.renderSelection();\n  } // This happens when a glob gets HMR-ed\n\n\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    super.onStoriesChanged({\n      importFn,\n      storyIndex\n    });\n\n    if (!global.FEATURES?.storyStoreV7) {\n      this.channel.emit(SET_STORIES, await this.storyStore.getSetStoriesPayload());\n    }\n\n    if (this.urlStore.selection) {\n      await this.renderSelection();\n    } else {\n      // Our selection has never applied before, but maybe it does now, let's try!\n      await this.selectSpecifiedStory();\n    }\n  }\n\n  onKeydown(event) {\n    if (!this.currentRender?.disableKeyListeners && !focusInInput(event)) {\n      // We have to pick off the keys of the event that we need on the other side\n      const {\n        altKey,\n        ctrlKey,\n        metaKey,\n        shiftKey,\n        key,\n        code,\n        keyCode\n      } = event;\n      this.channel.emit(PREVIEW_KEYDOWN, {\n        event: {\n          altKey,\n          ctrlKey,\n          metaKey,\n          shiftKey,\n          key,\n          code,\n          keyCode\n        }\n      });\n    }\n  }\n\n  onSetCurrentStory(selection) {\n    this.urlStore.setSelection(Object.assign({\n      viewMode: 'story'\n    }, selection));\n    this.channel.emit(CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    this.renderSelection();\n  }\n\n  onUpdateQueryParams(queryParams) {\n    this.urlStore.setQueryParams(queryParams);\n  }\n\n  async onUpdateGlobals({\n    globals\n  }) {\n    super.onUpdateGlobals({\n      globals\n    });\n  }\n\n  async onUpdateArgs({\n    storyId,\n    updatedArgs\n  }) {\n    super.onUpdateArgs({\n      storyId,\n      updatedArgs\n    });\n  }\n\n  async onPreloadStories(ids) {\n    await Promise.all(ids.map(id => this.storyStore.loadEntry(id)));\n  } // RENDERING\n  // We can either have:\n  // - a story selected in \"story\" viewMode,\n  //     in which case we render it to the root element, OR\n  // - a story selected in \"docs\" viewMode,\n  //     in which case we render the docsPage for that story\n\n\n  async renderSelection({\n    persistedArgs\n  } = {}) {\n    const {\n      renderToDOM\n    } = this;\n    if (!renderToDOM) throw new Error('Cannot call renderSelection before initialization');\n    const {\n      selection\n    } = this.urlStore;\n    if (!selection) throw new Error('Cannot call renderSelection as no selection was made');\n    const {\n      storyId\n    } = selection;\n    let entry;\n\n    try {\n      entry = await this.storyStore.storyIdToEntry(storyId);\n    } catch (err) {\n      if (this.currentRender) await this.teardownRender(this.currentRender);\n      this.renderStoryLoadingException(storyId, err);\n      return;\n    }\n\n    const storyIdChanged = this.currentSelection?.storyId !== storyId; // FIXME: suspect line\n\n    const viewModeChanged = this.currentRender?.type !== entry.type; // Show a spinner while we load the next story\n\n    if (entry.type === 'story') {\n      this.view.showPreparingStory({\n        immediate: viewModeChanged\n      });\n    } else {\n      this.view.showPreparingDocs();\n    } // If the last render is still preparing, let's drop it right now. Either\n    //   (a) it is a different story, which means we would drop it later, OR\n    //   (b) it is the *same* story, in which case we will resolve our own .prepare() at the\n    //       same moment anyway, and we should just \"take over\" the rendering.\n    // (We can't tell which it is yet, because it is possible that an HMR is going on and\n    //  even though the storyId is the same, the story itself is not).\n\n\n    if (this.currentRender?.isPreparing()) {\n      await this.teardownRender(this.currentRender);\n    }\n\n    let render;\n\n    if (entry.type === 'story') {\n      render = new StoryRender(this.channel, this.storyStore, (...args) => {\n        // At the start of renderToDOM we make the story visible (see note in WebView)\n        this.view.showStoryDuringRender();\n        return renderToDOM(...args);\n      }, this.mainStoryCallbacks(storyId), storyId, 'story');\n    } else if (entry.standalone) {\n      render = new StandaloneDocsRender(this.channel, this.storyStore, entry);\n    } else {\n      render = new TemplateDocsRender(this.channel, this.storyStore, entry);\n    } // We need to store this right away, so if the story changes during\n    // the async `.prepare()` below, we can (potentially) cancel it\n\n\n    const lastSelection = this.currentSelection;\n    this.currentSelection = selection;\n    const lastRender = this.currentRender;\n    this.currentRender = render;\n\n    try {\n      await render.prepare();\n    } catch (err) {\n      if (err !== PREPARE_ABORTED) {\n        // We are about to render an error so make sure the previous story is\n        // no longer rendered.\n        if (lastRender) await this.teardownRender(lastRender);\n        this.renderStoryLoadingException(storyId, err);\n      }\n\n      return;\n    }\n\n    const implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);\n\n    if (persistedArgs && isStoryRender(render)) {\n      if (!render.story) throw new Error('Render has not been prepared!');\n      this.storyStore.args.updateFromPersisted(render.story, persistedArgs);\n    } // Don't re-render the story if nothing has changed to justify it\n\n\n    if (lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {\n      this.currentRender = lastRender;\n      this.channel.emit(STORY_UNCHANGED, storyId);\n      this.view.showMain();\n      return;\n    } // Wait for the previous render to leave the page. NOTE: this will wait to ensure anything async\n    // is properly aborted, which (in some cases) can lead to the whole screen being refreshed.\n\n\n    if (lastRender) await this.teardownRender(lastRender, {\n      viewModeChanged\n    }); // If we are rendering something new (as opposed to re-rendering the same or first story), emit\n\n    if (lastSelection && (storyIdChanged || viewModeChanged)) {\n      this.channel.emit(STORY_CHANGED, storyId);\n    }\n\n    if (isStoryRender(render)) {\n      if (!render.story) throw new Error('Render has not been prepared!');\n      const {\n        parameters,\n        initialArgs,\n        argTypes,\n        args\n      } = this.storyStore.getStoryContext(render.story);\n\n      if (global.FEATURES?.storyStoreV7) {\n        this.channel.emit(STORY_PREPARED, {\n          id: storyId,\n          parameters,\n          initialArgs,\n          argTypes,\n          args\n        });\n      } // For v6 mode / compatibility\n      // If the implementation changed, or args were persisted, the args may have changed,\n      // and the STORY_PREPARED event above may not be respected.\n\n\n      if (implementationChanged || persistedArgs) {\n        this.channel.emit(STORY_ARGS_UPDATED, {\n          storyId,\n          args\n        });\n      }\n    }\n\n    if (isStoryRender(render)) {\n      if (!render.story) throw new Error('Render has not been prepared!');\n      this.storyRenders.push(render);\n      this.currentRender.renderToElement(this.view.prepareForStory(render.story));\n    } else {\n      this.currentRender.renderToElement(this.view.prepareForDocs(), this.renderStoryToElement.bind(this));\n    }\n  }\n\n  async teardownRender(render, {\n    viewModeChanged = false\n  } = {}) {\n    this.storyRenders = this.storyRenders.filter(r => r !== render);\n    await render?.teardown?.({\n      viewModeChanged\n    });\n  } // API\n\n\n  async extract(options) {\n    if (this.previewEntryError) {\n      throw this.previewEntryError;\n    }\n\n    if (!this.storyStore.projectAnnotations) {\n      // In v6 mode, if your preview.js throws, we never get a chance to initialize the preview\n      // or store, and the error is simply logged to the browser console. This is the best we can do\n      throw new Error(dedent`Failed to initialize Storybook.\n\n      Do you have an error in your \\`preview.js\\`? Check your Storybook's browser console for errors.`);\n    }\n\n    if (global.FEATURES?.storyStoreV7) {\n      await this.storyStore.cacheAllCSFFiles();\n    }\n\n    return this.storyStore.extract(options);\n  } // UTILITIES\n\n\n  mainStoryCallbacks(storyId) {\n    return {\n      showMain: () => this.view.showMain(),\n      showError: err => this.renderError(storyId, err),\n      showException: err => this.renderException(storyId, err)\n    };\n  }\n\n  inlineStoryCallbacks(storyId) {\n    return {\n      showMain: () => {},\n      showError: err => logger.error(`Error rendering docs story (${storyId})`, err),\n      showException: err => logger.error(`Error rendering docs story (${storyId})`, err)\n    };\n  }\n\n  renderPreviewEntryError(reason, err) {\n    super.renderPreviewEntryError(reason, err);\n    this.view.showErrorDisplay(err);\n  }\n\n  renderMissingStory() {\n    this.view.showNoPreview();\n    this.channel.emit(STORY_MISSING);\n  }\n\n  renderStoryLoadingException(storySpecifier, err) {\n    logger.error(`Unable to load story '${storySpecifier}':`);\n    logger.error(err);\n    this.view.showErrorDisplay(err);\n    this.channel.emit(STORY_MISSING, storySpecifier);\n  } // renderException is used if we fail to render the story and it is uncaught by the app layer\n\n\n  renderException(storyId, error) {\n    const {\n      name = 'Error',\n      message = String(error),\n      stack\n    } = error;\n    this.channel.emit(STORY_THREW_EXCEPTION, {\n      name,\n      message,\n      stack\n    });\n    this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    }); // Ignored exceptions exist for control flow purposes, and are typically handled elsewhere.\n\n    if (error !== IGNORED_EXCEPTION) {\n      this.view.showErrorDisplay(error);\n      logger.error(`Error rendering story '${storyId}':`);\n      logger.error(error);\n    }\n  } // renderError is used by the various app layers to inform the user they have done something\n  // wrong -- for instance returned the wrong thing from a story\n\n\n  renderError(storyId, {\n    title,\n    description\n  }) {\n    logger.error(`Error rendering story ${title}: ${description}`);\n    this.channel.emit(STORY_ERRORED, {\n      title,\n      description\n    });\n    this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    });\n    this.view.showErrorDisplay({\n      message: title,\n      stack: description\n    });\n  }\n\n}","import{a as o,b as _e,c as Je}from\"./chunk-4Y4H7JZH.mjs\";import{extractComponentDescription as Wr,enhanceArgTypes as Hr}from\"@storybook/docs-tools\";import xe from\"prop-types\";import{hasDocgen as Fr,extractComponentProps as br,TypeSystem as Re}from\"@storybook/docs-tools\";import{createSummaryValue as L,isTooLongForTypeSummary as tr}from\"@storybook/docs-tools\";function z(e,r){let t=e!=null,n=r!=null;if(!t&&!n)return\"\";let s=[];if(t){let a=e.map(l=>{let p=l.getPrettyName(),i=l.getTypeName();return i!=null?`${p}: ${i}`:p});s.push(`(${a.join(\", \")})`)}else s.push(\"()\");return n&&s.push(`=> ${r.getTypeName()}`),s.join(\" \")}o(z,\"generateFuncSignature\");function Q(e,r){let t=e!=null,n=r!=null;if(!t&&!n)return\"\";let s=[];return t?s.push(\"( ... )\"):s.push(\"()\"),n&&s.push(`=> ${r.getTypeName()}`),s.join(\" \")}o(Q,\"generateShortFuncSignature\");function Z(e){return e.replace(/,/g,`,\\r\n`)}o(Z,\"toMultilineSignature\");var P=\"custom\",g=\"object\",R=\"array\",ee=\"class\",d=\"func\",T=\"element\";import Ve from\"html-tags\";function A(e){return Ve.includes(e.toLowerCase())}o(A,\"isHtmlTag\");import{generate as ke}from\"escodegen\";import{dedent as De}from\"ts-dedent\";var re={format:{indent:{style:\"  \"},semicolons:!1}},ve={...re,format:{newline:\"\"}},Be={...re};function E(e,r=!1){return ke(e,r?ve:Be)}o(E,\"generateCode\");function F(e,r=!1){return r?$e(e):E(e)}o(F,\"generateObjectCode\");function $e(e){let r=E(e,!0);return r.endsWith(\" }\")||(r=`${r.slice(0,-1)} }`),r}o($e,\"generateCompactObjectCode\");function v(e,r=!1){return r?Ye(e):we(e)}o(v,\"generateArrayCode\");function we(e){let r=E(e);return r.endsWith(\"  }]\")&&(r=De(r)),r}o(we,\"generateMultilineArrayCode\");function Ye(e){let r=E(e,!0);return r.startsWith(\"[    \")&&(r=r.replace(\"[    \",\"[\")),r}o(Ye,\"generateCompactArrayCode\");var M=o(e=>e.$$typeof===Symbol.for(\"react.memo\"),\"isMemo\"),te=o(e=>e.$$typeof===Symbol.for(\"react.forward_ref\"),\"isForwardRef\");var u;(function(e){e.IDENTIFIER=\"Identifier\",e.LITERAL=\"Literal\",e.OBJECT=\"Object\",e.ARRAY=\"Array\",e.FUNCTION=\"Function\",e.CLASS=\"Class\",e.ELEMENT=\"Element\",e.UNKNOWN=\"Unknown\"})(u||(u={}));import{Parser as We}from\"acorn\";import He from\"acorn-jsx\";import*as C from\"acorn-walk\";var B={...C.base,JSXElement:()=>{}},Xe=We.extend(He());function b(e){return e!=null?e.name:null}o(b,\"extractIdentifierName\");function ne(e){return e.filter(r=>r.type===\"ObjectExpression\"||r.type===\"ArrayExpression\")}o(ne,\"filterAncestors\");function oe(e){let r=[];return C.ancestor(e,{ObjectExpression(t,n){r.push(ne(n).length)},ArrayExpression(t,n){r.push(ne(n).length)}},B),Math.max(...r)}o(oe,\"calculateNodeDepth\");function qe(e){return{inferredType:{type:u.IDENTIFIER,identifier:b(e)},ast:e}}o(qe,\"parseIdentifier\");function Ke(e){return{inferredType:{type:u.LITERAL},ast:e}}o(Ke,\"parseLiteral\");function Ge(e){let r;C.simple(e.body,{JSXElement(a){r=a}},B);let n={type:r!=null?u.ELEMENT:u.FUNCTION,params:e.params,hasParams:e.params.length!==0},s=b(e.id);return s!=null&&(n.identifier=s),{inferredType:n,ast:e}}o(Ge,\"parseFunction\");function ze(e){let r;return C.simple(e.body,{JSXElement(n){r=n}},B),{inferredType:{type:r!=null?u.ELEMENT:u.CLASS,identifier:b(e.id)},ast:e}}o(ze,\"parseClass\");function Qe(e){let r={type:u.ELEMENT},t=b(e.openingElement.name);return t!=null&&(r.identifier=t),{inferredType:r,ast:e}}o(Qe,\"parseJsxElement\");function Ze(e){let r=e.callee.type===\"MemberExpression\"?e.callee.property:e.callee;return b(r)===\"shape\"?se(e.arguments[0]):null}o(Ze,\"parseCall\");function se(e){return{inferredType:{type:u.OBJECT,depth:oe(e)},ast:e}}o(se,\"parseObject\");function er(e){return{inferredType:{type:u.ARRAY,depth:oe(e)},ast:e}}o(er,\"parseArray\");function rr(e){switch(e.type){case\"Identifier\":return qe(e);case\"Literal\":return Ke(e);case\"FunctionExpression\":case\"ArrowFunctionExpression\":return Ge(e);case\"ClassExpression\":return ze(e);case\"JSXElement\":return Qe(e);case\"CallExpression\":return Ze(e);case\"ObjectExpression\":return se(e);case\"ArrayExpression\":return er(e);default:return null}}o(rr,\"parseExpression\");function ae(e){let r=Xe.parse(`(${e})`),t={inferredType:{type:u.UNKNOWN},ast:r};if(r.body[0]!=null){let n=r.body[0];switch(n.type){case\"ExpressionStatement\":{let s=rr(n.expression);s!=null&&(t=s);break}default:break}}return t}o(ae,\"parse\");function y(e){try{return{...ae(e)}}catch{}return{inferredType:{type:u.UNKNOWN}}}o(y,\"inspectValue\");var nr=150,c;(function(e){e.CUSTOM=\"custom\",e.ANY=\"any\",e.FUNC=\"func\",e.SHAPE=\"shape\",e.OBJECT=\"object\",e.INSTANCEOF=\"instanceOf\",e.OBJECTOF=\"objectOf\",e.UNION=\"union\",e.ENUM=\"enum\",e.ARRAYOF=\"arrayOf\",e.ELEMENT=\"element\",e.ELEMENTTYPE=\"elementType\",e.NODE=\"node\"})(c||(c={}));function m({name:e,short:r,compact:t,full:n,inferredType:s}){return{name:e,short:r,compact:t,full:n??r,inferredType:s}}o(m,\"createTypeDef\");function fe(e){return e.replace(/PropTypes./g,\"\").replace(/.isRequired/g,\"\")}o(fe,\"cleanPropTypes\");function ue(e){return e.split(/\\r?\\n/)}o(ue,\"splitIntoLines\");function U(e,r=!1){return fe(F(e,r))}o(U,\"prettyObject\");function ie(e,r=!1){return fe(E(e,r))}o(ie,\"prettyArray\");function or(e){switch(e){case u.OBJECT:return g;case u.ARRAY:return R;case u.CLASS:return ee;case u.FUNCTION:return d;case u.ELEMENT:return T;default:return P}}o(or,\"getCaptionForInspectionType\");function pe(e,r){let{inferredType:t,ast:n}=y(e),{type:s}=t,a,l,p;switch(s){case u.IDENTIFIER:case u.LITERAL:a=e,l=e;break;case u.OBJECT:{let{depth:i}=t;a=g,l=i===1?U(n,!0):null,p=U(n);break}case u.ELEMENT:{let{identifier:i}=t;a=i!=null&&!A(i)?i:T,l=ue(e).length===1?e:null,p=e;break}case u.ARRAY:{let{depth:i}=t;a=R,l=i<=2?ie(n,!0):null,p=ie(n);break}default:a=or(s),l=ue(e).length===1?e:null,p=e;break}return m({name:r,short:a,compact:l,full:p,inferredType:s})}o(pe,\"generateTypeFromString\");function sr({raw:e}){return e!=null?pe(e,c.CUSTOM):m({name:c.CUSTOM,short:P,compact:P})}o(sr,\"generateCustom\");function ar(e){let{jsDocTags:r}=e;return r!=null&&(r.params!=null||r.returns!=null)?m({name:c.FUNC,short:Q(r.params,r.returns),compact:null,full:z(r.params,r.returns)}):m({name:c.FUNC,short:d,compact:d})}o(ar,\"generateFunc\");function ur(e,r){let t=Object.keys(e.value).map(l=>`${l}: ${S(e.value[l],r).full}`).join(\", \"),{inferredType:n,ast:s}=y(`{ ${t} }`),{depth:a}=n;return m({name:c.SHAPE,short:g,compact:a===1&&s?U(s,!0):null,full:s?U(s):null})}o(ur,\"generateShape\");function $(e){return`objectOf(${e})`}o($,\"objectOf\");function ir(e,r){let{short:t,compact:n,full:s}=S(e.value,r);return m({name:c.OBJECTOF,short:$(t),compact:n!=null?$(n):null,full:s&&$(s)})}o(ir,\"generateObjectOf\");function cr(e,r){if(Array.isArray(e.value)){let t=e.value.reduce((n,s)=>{let{short:a,compact:l,full:p}=S(s,r);return n.short.push(a),n.compact.push(l),n.full.push(p),n},{short:[],compact:[],full:[]});return m({name:c.UNION,short:t.short.join(\" | \"),compact:t.compact.every(n=>n!=null)?t.compact.join(\" | \"):null,full:t.full.join(\" | \")})}return m({name:c.UNION,short:e.value,compact:null})}o(cr,\"generateUnion\");function lr({value:e,computed:r}){return r?pe(e,\"enumvalue\"):m({name:\"enumvalue\",short:e,compact:e})}o(lr,\"generateEnumValue\");function fr(e){if(Array.isArray(e.value)){let r=e.value.reduce((t,n)=>{let{short:s,compact:a,full:l}=lr(n);return t.short.push(s),t.compact.push(a),t.full.push(l),t},{short:[],compact:[],full:[]});return m({name:c.ENUM,short:r.short.join(\" | \"),compact:r.compact.every(t=>t!=null)?r.compact.join(\" | \"):null,full:r.full.join(\" | \")})}return m({name:c.ENUM,short:e.value,compact:e.value})}o(fr,\"generateEnum\");function w(e){return`${e}[]`}o(w,\"braceAfter\");function ce(e){return`[${e}]`}o(ce,\"braceAround\");function le(e,r,t){return m({name:c.ARRAYOF,short:w(e),compact:r!=null?ce(r):null,full:t&&ce(t)})}o(le,\"createArrayOfObjectTypeDef\");function pr(e,r){let{name:t,short:n,compact:s,full:a,inferredType:l}=S(e.value,r);if(t===c.CUSTOM){if(l===u.OBJECT)return le(n,s,a)}else if(t===c.SHAPE)return le(n,s,a);return m({name:c.ARRAYOF,short:w(n),compact:w(n)})}o(pr,\"generateArray\");function S(e,r){try{switch(e.name){case c.CUSTOM:return sr(e);case c.FUNC:return ar(r);case c.SHAPE:return ur(e,r);case c.INSTANCEOF:return m({name:c.INSTANCEOF,short:e.value,compact:e.value});case c.OBJECTOF:return ir(e,r);case c.UNION:return cr(e,r);case c.ENUM:return fr(e);case c.ARRAYOF:return pr(e,r);default:return m({name:e.name,short:e.name,compact:e.name})}}catch(t){console.error(t)}return m({name:\"unknown\",short:\"unknown\",compact:\"unknown\"})}o(S,\"generateType\");function me(e){let{type:r}=e.docgenInfo;if(r==null)return null;try{switch(r.name){case c.CUSTOM:case c.SHAPE:case c.INSTANCEOF:case c.OBJECTOF:case c.UNION:case c.ENUM:case c.ARRAYOF:{let{short:t,compact:n,full:s}=S(r,e);return n!=null&&!tr(n)?L(n):s?L(t,s):L(t)}case c.FUNC:{let{short:t,full:n}=S(r,e),s=t,a;return n&&n.length<nr?s=n:n&&(a=Z(n)),L(s,a)}default:return null}}catch(t){console.error(t)}return null}o(me,\"createType\");import{createSummaryValue as x,isTooLongForDefaultValueSummary as Te}from\"@storybook/docs-tools\";import{createSummaryValue as ye,isTooLongForDefaultValueSummary as mr}from\"@storybook/docs-tools\";function _({inferredType:e,ast:r}){let{depth:t}=e;if(t===1){let n=F(r,!0);if(!mr(n))return ye(n)}return ye(g,F(r))}o(_,\"generateObject\");import{createSummaryValue as de,isTooLongForDefaultValueSummary as yr}from\"@storybook/docs-tools\";function J({inferredType:e,ast:r}){let{depth:t}=e;if(t<=2){let n=v(r,!0);if(!yr(n))return de(n)}return de(R,v(r))}o(J,\"generateArray\");function j(e,r){return r?`${e}( ... )`:`${e}()`}o(j,\"getPrettyFuncIdentifier\");function I(e){return`<${e} />`}o(I,\"getPrettyElementIdentifier\");function Y(e){let{type:r,identifier:t}=e;switch(r){case u.FUNCTION:return j(t,e.hasParams);case u.ELEMENT:return I(t);default:return t}}o(Y,\"getPrettyIdentifier\");function dr({inferredType:e,ast:r}){let{identifier:t}=e;if(t!=null)return x(Y(e),E(r));let n=E(r,!0);return Te(n)?x(d,E(r)):x(n)}o(dr,\"generateFunc\");function Tr(e,r){let{inferredType:t}=r,{identifier:n}=t;if(n!=null&&!A(n)){let s=Y(t);return x(s,e)}return Te(e)?x(T,e):x(e)}o(Tr,\"generateElement\");function V(e){try{let r=y(e);switch(r.inferredType.type){case u.OBJECT:return _(r);case u.FUNCTION:return dr(r);case u.ELEMENT:return Tr(e,r);case u.ARRAY:return J(r);default:return null}}catch(r){console.error(r)}return null}o(V,\"createDefaultValue\");import Er from\"lodash/isPlainObject\";import Ee from\"lodash/isFunction\";import Or from\"lodash/isString\";import Oe from\"react-element-to-jsx-string\";import{createSummaryValue as O,isTooLongForDefaultValueSummary as gr}from\"@storybook/docs-tools\";function ge(e){return e.$$typeof!=null}o(ge,\"isReactElement\");function W(e,r){let{name:t}=e;return t!==\"\"&&t!==\"anonymous\"&&t!==r?t:null}o(W,\"extractFunctionName\");var hr=o(e=>O(JSON.stringify(e)),\"stringResolver\");function Nr(e){let{type:r}=e,{displayName:t}=r,n=Oe(e,{});if(t!=null){let s=I(t);return O(s,n)}if(Or(r)&&A(r)){let a=Oe(e,{tabStop:0}).replace(/\\r?\\n|\\r/g,\"\");if(!gr(a))return O(a)}return O(T,n)}o(Nr,\"generateReactObject\");var Cr=o(e=>{if(ge(e)&&e.type!=null)return Nr(e);if(Er(e)){let r=y(JSON.stringify(e));return _(r)}if(Array.isArray(e)){let r=y(JSON.stringify(e));return J(r)}return O(g)},\"objectResolver\"),Ar=o((e,r)=>{let t=!1,n;if(Ee(e.render))t=!0;else if(e.prototype!=null&&Ee(e.prototype.render))t=!0;else{let a;try{n=y(e.toString());let{hasParams:l,params:p}=n.inferredType;l?p.length===1&&p[0].type===\"ObjectPattern\"&&(a=e({})):a=e(),a!=null&&ge(a)&&(t=!0)}catch{}}let s=W(e,r.name);if(s!=null){if(t)return O(I(s));n!=null&&(n=y(e.toString()));let{hasParams:a}=n.inferredType;return O(j(s,a))}return O(t?T:d)},\"functionResolver\"),Sr=o(e=>O(e.toString()),\"defaultResolver\"),he={string:hr,object:Cr,function:Ar,default:Sr};function Ne(e={}){return{...he,...e}}o(Ne,\"createTypeResolvers\");function k(e,r,t=he){try{switch(typeof e){case\"string\":return t.string(e,r);case\"object\":return t.object(e,r);case\"function\":return t.function(e,r);default:return t.default(e,r)}}catch(n){console.error(n)}return null}o(k,\"createDefaultValueFromRawDefaultProp\");function Ce(e,r){let{propTypes:t}=r;return t!=null?Object.keys(t).map(n=>e.find(s=>s.name===n)).filter(Boolean):e}o(Ce,\"keepOriginalDefinitionOrder\");import{createSummaryValue as H}from\"@storybook/docs-tools\";var Ir=o((e,{name:r,type:t})=>{let n=t.summary===\"element\"||t.summary===\"elementType\",s=W(e,r);if(s!=null){if(n)return H(I(s));let{hasParams:a}=y(e.toString()).inferredType;return H(j(s,a))}return H(n?T:d)},\"funcResolver\"),Ae=Ne({function:Ir});function xr(e,r){let{propDef:t}=e,n=me(e);n!=null&&(t.type=n);let{defaultValue:s}=e.docgenInfo;if(s!=null&&s.value!=null){let a=V(s.value);a!=null&&(t.defaultValue=a)}else if(r!=null){let a=k(r,t,Ae);a!=null&&(t.defaultValue=a)}return t}o(xr,\"enhancePropTypesProp\");function Se(e,r){let t=r.defaultProps!=null?r.defaultProps:{},n=e.map(s=>xr(s,t[s.propDef.name]));return Ce(n,r)}o(Se,\"enhancePropTypesProps\");function Rr(e,r){let{propDef:t}=e,{defaultValue:n}=e.docgenInfo;if(n!=null&&n.value!=null){let s=V(n.value);s!=null&&(t.defaultValue=s)}else if(r!=null){let s=k(r,t);s!=null&&(t.defaultValue=s)}return t}o(Rr,\"enhanceTypeScriptProp\");function Ie(e){return e.map(r=>Rr(r))}o(Ie,\"enhanceTypeScriptProps\");var Fe=new Map;Object.keys(xe).forEach(e=>{let r=xe[e];Fe.set(r,e),Fe.set(r.isRequired,e)});function jr(e,r){let t=e;!Fr(e)&&!e.propTypes&&M(e)&&(t=e.type);let n=br(t,r);if(n.length===0)return[];switch(n[0].typeSystem){case Re.JAVASCRIPT:return Se(n,e);case Re.TYPESCRIPT:return Ie(n);default:return n.map(s=>s.propDef)}}o(jr,\"getPropDefs\");var be=o(e=>({rows:jr(e,\"props\")}),\"extractProps\");var je=o(e=>{if(e){let{rows:r}=be(e);if(r)return r.reduce((t,n)=>{let{name:s,description:a,type:l,sbType:p,defaultValue:i,jsDocTags:h,required:N}=n;return t[s]={name:s,description:a,type:{required:N,...p},table:{type:l,jsDocTags:h,defaultValue:i}},t},{})}return null},\"extractArgTypes\");import X,{createElement as Pr}from\"react\";import Mr from\"react-element-to-jsx-string\";import{dedent as Lr}from\"ts-dedent\";import Ur from\"util-deprecate\";import{addons as _r,useEffect as Jr}from\"@storybook/addons\";import{SourceType as Pe,SNIPPET_RENDERED as Vr,getDocgenSection as kr}from\"@storybook/docs-tools\";import{logger as D}from\"@storybook/client-logger\";function q(){return q=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},q.apply(this,arguments)}o(q,\"_extends\");var Dr=o((e,r)=>typeof r.onBeforeRender!=\"function\"?e:Ur(r.onBeforeRender,Lr`\n      StoryFn.parameters.jsx.onBeforeRender was deprecated.\n      Prefer StoryFn.parameters.jsx.transformSource instead.\n      See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-onbeforerender for details.\n    `)(e),\"applyBeforeRender\"),vr=o((e,r,t)=>typeof r.transformSource!=\"function\"?e:r.transformSource(e,t),\"applyTransformSource\"),Br=o((e,r)=>{if(typeof e>\"u\")return D.warn(\"Too many skip or undefined component\"),null;let t=e,n=t.type;for(let i=0;i<r.skip;i+=1){if(typeof t>\"u\")return D.warn(\"Cannot skip undefined element\"),null;if(X.Children.count(t)>1)return D.warn(\"Trying to skip an array of elements\"),null;typeof t.props.children>\"u\"?(D.warn(\"Not enough children to skip elements.\"),typeof t.type==\"function\"&&t.type.name===\"\"&&(t=X.createElement(n,q({},t.props)))):typeof t.props.children==\"function\"?t=t.props.children():t=t.props.children}let l={...typeof r.displayName==\"string\"?{showFunctions:!0,displayName:()=>r.displayName}:{displayName:i=>i.type.displayName||kr(i.type,\"displayName\")||(i.type.name!==\"_default\"?i.type.name:null)||(typeof i.type==\"function\"?\"No Display Name\":null)||(te(i.type)?i.type.render.name:null)||(M(i.type)?i.type.type.name:null)||i.type},...{filterProps:(i,h)=>i!==void 0},...r};return X.Children.map(e,i=>{let h=typeof i==\"number\"?i.toString():i,N=Dr(Mr(h,l),r);if(N.indexOf(\"&quot;\")>-1){let K=N.match(/\\S+=\\\\\"([^\"]*)\\\\\"/g);K&&K.forEach(G=>{N=N.replace(G,G.replace(/&quot;/g,\"'\"))})}return N}).join(`\n`).replace(/function\\s+noRefCheck\\(\\)\\s+\\{\\}/,\"() => {}\")},\"renderJsx\"),$r={skip:0,showFunctions:!1,enableBeautify:!0,showDefaultProps:!1},wr=o(e=>{let r=e?.parameters.docs?.source,t=e?.parameters.__isArgsStory;return r?.type===Pe.DYNAMIC?!1:!t||r?.code||r?.type===Pe.CODE},\"skipJsxRender\"),Yr=o(e=>e.type?.displayName===\"MDXCreateElement\"&&!!e.props?.mdxType,\"isMdx\"),Me=o(e=>{if(!Yr(e))return e;let{mdxType:r,originalType:t,children:n,...s}=e.props,a=[];return n&&(a=(Array.isArray(n)?n:[n]).map(Me)),Pr(t,s,...a)},\"mdxToJsx\"),Le=o((e,r)=>{let t=_r.getChannel(),n=wr(r),s=\"\";Jr(()=>{n||t.emit(Vr,(r||{}).id,s)});let a=e();if(n)return a;let l={...$r,...r?.parameters.jsx||{}},p=r?.parameters.docs?.source?.excludeDecorators?r.originalStoryFn(r.args,r):a,i=Me(p),h=Br(i,l);return h&&(s=vr(h,l,r)),a},\"jsxDecorator\");var Ue={docs:{inlineStories:!0,extractArgTypes:je,extractComponentDescription:Wr}},Xr=[Le],qr=[Hr];var Bn={framework:\"react\",...Ue};export{qr as argTypesEnhancers,Xr as decorators,Bn as parameters,_e as render,Je as renderToDOM};\n"],"names":[],"sourceRoot":""}